---
layout:     post
title:      数据结构
subtitle:   树与图
date:       2022-11-22
author:     maple
header-img: img/4k-gaming-mountain.jpg
catalog: true
tags:
    - 学习资料
---
> <a name="kfSiH"></a>
### 创建及遍历二叉树

<a name="Uup9a"></a>
## 遍历二叉树的递归算法
```cpp
#include <iostream>
#include <string>
#include <cstdlib>
using namespace std;


//先序 中序 后序遍历二叉树
typedef struct Tree{
    int data;
    struct Tree *lchild;
    struct Tree *rchild;
}Tree;

Tree* Creatlink(){
    int data;
    Tree* T;

    cin>>data;
    getchar();

//递归调用遍历二叉树
    if(data==-1){
        return NULL;
    }else{
        T = new Tree;
        T->data=data;
        cout<<"请输入"<<data<<"的左子树:"<<endl;
        T->lchild=Creatlink();
        cout<<"请输入"<<data<<"的右子树:"<<endl;
        T->rchild=Creatlink();
        return T;
    }
}
    //	先序遍历
void ShowXianXu(Tree* T){			//先序遍历二叉树

	if(T==NULL){					//递归中遇到NULL，返回上一层节点
		return;
	}
	printf("%d ",T->data);
	ShowXianXu(T->lchild);			//递归遍历左子树
	ShowXianXu(T->rchild);			//递归遍历右子树
}
//	中序遍历
void ShowZhongXu(Tree* T){			//先序遍历二叉树

	if(T==NULL)						//递归中遇到NULL，返回上一层节点
	{
		return;
	}
	
	ShowZhongXu(T->lchild);			//	递归遍历左子树
	printf("%d ",T->data);
	ShowZhongXu(T->rchild);			//	递归遍历右子树
	
}
//	后序遍历
void ShowHouXu(Tree* T){			//		后序遍历二叉树
	if(T==NULL){					//	递归中遇到NULL，返回上一层节点
		return;
	}
	
	ShowHouXu(T->lchild);			//	递归遍历左子树
	ShowHouXu(T->rchild);			//	递归遍历右子树
	printf("%d ",T->data);
}


int main(){
	Tree* S;
	printf("请输入第一个节点的数据:\n");
	S = Creatlink();			//		接受创建二叉树完成的根节点
	printf("先序遍历结果: \n");
	ShowXianXu(S);				//		先序遍历二叉树

	printf("\n中序遍历结果: \n");
	ShowZhongXu(S);				//		中序遍历二叉树
	
	printf("\n后序遍历结果: \n");
	ShowHouXu(S);				//		后序遍历二叉树
    system("pause");
	return 0;	
} 	


```

<a name="nmAkD"></a>
## 遍历二叉树的非递归算法
<a name="dABHN"></a>
###  中序遍历非递归算法
关键点：在中序遍历过某个节点的整个左子树后，如何找到该节点的根以及右子树<br />基本思想：

1. 建立一个栈
2. 根节点进栈，遍历左子树
3. 根节点出栈，输出根节点，遍历右子树

（遇见根节点先不访问，将其入栈，继续访问左子树，左子树为空时，访问根节点出栈，再遍历右子树<br />创建一个函数，将树的根节点传入，在函数中创建一个空栈，指针变量p指向根节点，如果p存在且栈不为空，执行if，将当前指向的根节点入栈，不输出，继续让当前p指向的节点的左孩子赋值给p，即`p=p->lchild`，访问左子树，如果存在，则重复以上操作，如果p为空，但栈不为空，则执行else，弹出当前栈顶元素，令q指向当前访问的根节点，输出其的数值，根输出完，应当遍历右子树，令`p=q->rchild`，再次执行时如果p不为空，则执行if，根节点入栈，不输出，p指向左孩子，重复操作。

<a name="vEAFN"></a>
### 二叉树的层次遍历
利用队列的思想，可以实现二叉树的层次遍历<br />设计思路：

1. 将根节点入队
2. 队不为空时循环：从队列中列出一个节点*p，访问它
            1. 若它有左孩子节点，将左孩子入队
            2. 若它有右孩子节点，将右孩子入队

首先初始化队列，先让根结点指针进入队列，若队列不为空，则进入循环，先出队队头节点，如果它存在左孩子，则左孩子入队；若存在右孩子，则右孩子入队，先左孩子，后右孩子。


<a name="DiEBS"></a>
## 二叉树的建立
<a name="SZvX2"></a>
### 
<a name="vlnyC"></a>
### 按照先序遍历序列建议二叉树的二叉链表
如果只知道先序序列，无法构建出唯一的二叉树，所以在树中补充空节点<br />例：ABCDEGF ----> ABC##DE#G##F###<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/34408480/1669193226378-a22e45fd-7139-425f-b4d2-aaa55123a429.png#averageHue=%23ebe8e8&clientId=u0d480dd9-98b6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=201&id=ucb0f28f7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=393&originWidth=1137&originalType=binary&ratio=1&rotation=0&showTitle=false&size=147538&status=done&style=none&taskId=u89795360-07e8-4a8d-b97e-80d491c35eb&title=&width=582.0480346679688)<br />伪代码：<br />递归算法，调用自身，构建二叉树<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/34408480/1669193316553-cde1c98b-119e-4251-8258-14c71413e532.png#averageHue=%23f1f1f1&clientId=u0d480dd9-98b6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=436&id=ucad0acef&margin=%5Bobject%20Object%5D&name=image.png&originHeight=577&originWidth=778&originalType=binary&ratio=1&rotation=0&showTitle=false&size=246516&status=done&style=none&taskId=u7bf68e5f-e504-4329-87ce-1d0c9d1da06&title=&width=588.2384033203125)<br />遇到空字符，构造空树；如果不是空字符，申请节点空间

<a name="cILaS"></a>
### 复制二叉树
先序遍历复制二叉树<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/34408480/1669197228642-724e4a0a-03f6-4970-94cd-3fb10c10044c.png#averageHue=%23eeeceb&clientId=u0d480dd9-98b6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=369&id=u558891c8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=657&originWidth=1091&originalType=binary&ratio=1&rotation=0&showTitle=false&size=352694&status=done&style=none&taskId=uf9cceff9-182a-445f-b0ff-44f39166740&title=&width=612.0480346679688)<br />可以看出先序遍历复制二叉树和先序遍历递归建立二叉树的操作大致类似，只是将先序遍历二叉树的访问根节点在复制中换成了创建和复制根节点<br />递归调用，在函数中调用自身，其实上一层调用并没有执行完毕就执行下一层的调用，下一层调用执行完毕要回到上一层调用，继续往下执行。下一层执行完毕或者退出会回到上一层

<a name="Ooy2l"></a>
### 求二叉树节点总数
![image.png](https://cdn.nlark.com/yuque/0/2022/png/34408480/1669198246134-06713198-c524-4cbc-98b6-dce574807986.png#averageHue=%23c4c1ba&clientId=u0d480dd9-98b6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=50&id=u3ca74d9d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=94&originWidth=1158&originalType=binary&ratio=1&rotation=0&showTitle=false&size=133654&status=done&style=none&taskId=ua1ef4ab2-3a51-4713-9e51-5de576ac1e1&title=&width=615.0480346679688)<br />![image.png](https://cdn.nlark.com/yuque/0/2022/png/34408480/1669198262423-a3d6ac45-f71f-4b40-8afa-ee00c609143a.png#averageHue=%23eeeeee&clientId=u0d480dd9-98b6-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=248&id=ub0aa7819&margin=%5Bobject%20Object%5D&name=image.png&originHeight=342&originWidth=736&originalType=binary&ratio=1&rotation=0&showTitle=false&size=88560&status=done&style=none&taskId=u8e8760c1-5001-4353-8d0f-7d392456938&title=&width=534.2178344726562)<br />如果是空树，则返回0；通过递归调用计算节点总数
