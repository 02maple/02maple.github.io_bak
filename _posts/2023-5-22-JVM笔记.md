---
layout:     post
title:      JVM
subtitle:   JVM学习笔记
date:       2023-5-22
author:     maple
header-img: img/background001.jpg
catalog:   true
tags:
    - 学习资料
---


<a name="bV60x"></a>
### 第2章  Java内存区域与内存溢出异常  
<a name="JLjFx"></a>
#### 2.2 运行时数据区
**Java虚拟机**在执行Java程序的过程中会把他所管理的内存**划分为若干个不同的数据区域**，**每个区域的用处各不相同**，以及有各自的创建和销毁的时间，同时有的区域**依赖的是虚拟机进程**，而有的区域**依赖的是用户的线程**，Java虚拟机所管理的内存会包括以下几个运行时数据区<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683188349274-8417023a-3f2d-407f-9b3f-4c0de0ae3c61.png#averageHue=%23f6f6f2&clientId=u43461ecb-0ed8-4&from=paste&height=440&id=u345f9137&originHeight=770&originWidth=889&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=282478&status=done&style=none&taskId=ue985a259-3d7d-4da5-a91c-99987929ce3&title=&width=508)
<a name="jJiPZ"></a>
##### 2.2.1 程序计数器 (Program Counter Register)
程序计数器是一块较小的内存空间，是属于由线程隔离的数据区，可以看作是**当前线程所执行的字节码的行号指示器**。因为字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，而程序计数器即可代表字节码的行号，对应着相应的字节码指令。 分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br />Java虚拟机的多线程是通过线程轮流切换，分配处理器执行时间的方式来实现的，所以在任何时刻，一个处理器只会执行一条线程中的指令，用于不同线程会进行切回，而为了在切换线程之后，能够使该条线程恢复到正确的执行指令位置，**每条线程都需要一个程序计数器**，且**各条线程之间的程序计数器相互独立**，互不影响，独立存储，我们称这类内存区域为"**线程私有**"的内存，也就是上图所示的线程隔离的数据区。
<a name="aAthU"></a>
##### 2.2.2 Java虚拟机栈 (Java Virtual Machine Stack)
Java虚拟机栈也是属于**线程私有**的，处于线程隔离的数据区，其**生命周期与线程同步**。虚拟机栈描述的是**Java方法执行的线程内存模型：**每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表，操作数栈，动态链接，方法出口等信息。**每一个方法**被调用直至执行完毕的过程，就**对应着一个栈帧**在虚拟机栈中从入栈到出栈的过程。<br />Java内存区**不能笼统地划分**为堆内存和栈内存，不过这种划分方式间接的说明了程序员最关注的，与对象分配关系最密切的区域是'**堆(heap)**'和'**栈(stack)**'，而这里的栈通常指的就是虚拟机栈，或者更多的情况下只是指虚拟机栈中**局部变量表部分**。<br />**局部变量表**里存放了**编译期可知**的各种**Java虚拟机的基本数据类型** (boolean、byte、char、short、int、 float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址)  <br />这些数据类型在**局部变量表中的存储空间以局部变量槽(Slot)来表示**，其中64位长度的long和double类型会占用2个变量槽，其余只占用1个变量槽(一个槽位占32位)。**局部变量表所需的内存空间**在**编译期间完成分配**，当进入一个方法时，这个方法需要在**栈帧中分配多大的局部变量空间**是**完全确定**的，在方法运行期间**不改变局部变量表的大小**。(**大小指的是局部变量槽的槽位数量**，而虚拟机使用多大的内存空间，也就是1个变量槽位占用多少比特，是由虚拟机自行决定的)。
<a name="LsDUU"></a>
##### 2.2.3 本地方法栈 (Native Method Stacks)
本地方法栈与虚拟机栈所发挥的作用非常相似，其区别只是**虚拟机栈**为**虚拟机执行Java方法(也就是字节码)服务**，而**本地方法栈**则是为**虚拟机使用到的本地(Native)方法服务**。<br />《Java虚拟机规范》对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规 定，因此具体的虚拟机可以根据需要自由实现它，甚至有的Java虚拟机（譬如Hot-Spot虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失 败时分别抛出StackOverflowError和OutOfMemoryError异常。
<a name="yTvC8"></a>
##### 2.2.4 Java堆
对于Java应用程序来说，**Java堆**(Java Heap)是**虚拟机所管理的内存中最大的一块**。Java堆是被**所有线程共享**的一块内存区域，在**虚拟机启动时创建**。此内存区域的**唯一目的就是存放对象的实例**，Java中'几乎'所有的对象实例都在这里分配内存。<br />Java堆是垃圾收集器管理的内存区域，一些资料中将它成为'GC堆'(Garbage Collected Heap)。从回收内存的角度上看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以Java堆中经常会出现'新生代' '老年代' '永久代' 'Eden空间' 'From Survivor空间' 'To Survivor空间'等名词，**这些区域的划分仅仅是一部分垃圾收集器的共同特性或者说是设计风格而已**，而并非某个Java虚拟机具体的实现固有布局，在G1收集器出现之后，打破了这个特性，不再基于'经典分代'来设计。<br />如果从分配内存的角度看，所有线程共享的Java堆中**可以划分**出**多个线程私有的分配缓冲区**，提升对象分配时的效率。不过不论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，**存储的都只能是对象的实例**，将**Java堆细分的目的**只是为了**更好的回收内存**，或者**更快的分配内存**。<br /> 根据《Java虚拟机规范》的规定，**Java堆可以处于物理上不连续的内存空间中**，但在**逻辑上它应该被视为连续的**，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。但**对于大对象**（典型的如数组对象），多数虚拟机实现出于实现简单、存储高效的考虑，**很可能会要求连续的内存空间 。**<br /> **Java堆**既**可以被实现成固定大小**的，也**可以是可扩展**的，不过当前主流的Java虚拟机都是按照可扩展来实现的（通过参数-Xmx和-Xms设定）。如果在Java堆中没有内存完成实例分配，并且堆也无法再扩展时，Java虚拟机将会抛出OutOfMemoryError异常。
<a name="K0rlx"></a>
##### 2.2.5 方法区
方法区(Method Area)与Java堆一样，是**所有线程共享**的内存区域，它用于**存储已被虚拟机加载**的**类型信息，常量，静态变量**，即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把**方法区**描述为**堆的一个逻辑部分**，但是它却有一个别名叫作"**非堆**"（Non-Heap），目的是与Java堆区分开来。<br />**堆区**是用来**存储对象实例及数组对象的内存空间**，它是Java程序中最大的一块内存区域。当我们使用**new关键字创建一个对象**时，这个**对象就会被存储在堆区**中。每个对象都有自己独立的成员变量值、对象头信息和一些额外信息。<br />**方法区**是用来**存储类信息**、**常量**、**静态变量等数据的内存空间**。它是不同于堆区的另一个内存区域，方法区是被所有线程共享的，在JVM启动时即被创建，并分配了足够的内存空间。方法区中存储的内容包括类的完整信息、静态变量、常量以及编译器编译后的代码等。<br />在使用一个类创建对象实例的时候，JVM会首先从**方法区中加载该类的相关信息**。这些信息包括类的定义、常量池、静态变量、类方法等。<br />当我们使用关键字“new”创建一个对象时，JVM会在**堆内存中分配一块内存空间**，并调用合适的构造函数完成对象的初始化工作。在进行对象初始化之前，JVM会检查该类是否已经被加载和链接过，如果没有，则会先从磁盘或网络中加载类的字节码文件，并将其存储在方法区中。然后，JVM会对类进行链接和初始化操作，包括验证类的合法性、为静态变量赋初值、解析符号引用等。<br />因此，在**使用一个类创建对象实例的过程中，JVM需要从方法区中加载并初始化该类的相关信息**。只有当类的信息准备完毕后，才能够创建出相应的对象实例并执行相应的操作。
<a name="ZKFuW"></a>
##### 2.2.6 运行时常量池
 **运行时常量池**（Runtime Constant Pool）是**方法区的一部分**。**Class文件**中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是**常量池表**(Constant Pool Table)，用于**存放编译期生成的各种字面量与符号引用**，这部分内容在**类加载后存放到方法区的运行时常量池中**。<br />Java虚拟机对于Class文件的每一部分的格式都有严格的规定， 如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，**但对于运行时常量池，《Java虚拟机规范》并没有做任何细节的要求**，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，**除了保存Class文件中描述的符号引用外**，还会把由**符号引用翻译出来的直接引用**也**存储在运行时常量池中。**<br />**运行时常量池**相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，**运行期间也可以将新的常量放入池中**。
<a name="cglX7"></a>
##### 2.2.7 直接内存
 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现，本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括物理内存、SWAP分区或者分页文件）大小以及处理器寻址空间的限制，一般服务器管理员配置虚拟机参数时，会根据实际内存去设置-Xmx等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现 OutOfMemoryError异常。<br />直接内存是一种特殊的内存区域，它不受Java虚拟机（JVM）管理。与JVM管理的堆内存不同，**直接内存由操作系统管理**，并且可以通过Java NIO（New I/O）库访问。直接内存**通常用于需要快速、高效地读写大量数据的应用程序中**。这是因为**直接内存可以使用零拷贝（zero-copy）技术**，即数据可以在CPU和I/O设备之间直接传输，而不需要复制到堆内存中。

<a name="kT6Z6"></a>
#### 2.3 HotSpot虚拟机对象探秘
<a name="DLp6T"></a>
##### 2.3.1 对象的创建
Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常仅仅是一个new关键字而已，而在虚拟机中，当Java虚拟机遇到一条字节码new指令时，**首先会去检查这个指令的参数能否在常量池中定位到一个类的符号引用**，并且检查这个符号引用代表的类**是否已被加载，解析和初始化**过。如果没有，那必须先执行相应的类加载过程。<br />在类加载检查通过后，接下来虚拟机将为新生对象分配内存。**对象所需的内存大小在类加载完成后便可完全确定**。内存分配完成之后，**虚拟机必须将分配到的内存空间都初始化为零值**(但不包括对象头)，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。这步操作保证了对象的实例字段在Java代码中可以不赋初值就可以直接使用。程序访问到的这些字段的数据类型所对应的零值。<br />接下来，Java虚拟机会对对象进行必要的设置，例如这个对象时哪个类的实例，如何才能找到这类的元数据信息，对象的哈希码，对象的gc分代年龄等信息，这些**信息会放在对象头中**。<br />上面的工作完成之后，从Java程序的视角来看，对象创建才刚刚开始----**构造函数，即Class文件中的<init>()方法还没有执行，所有的字段都为默认的零值**，对象所需要的其他资源和状态信息也还没有按照预定的意图构造好，**一般来说，new指令之后会接着执行<init>()方法**。<br />*如果**Java堆规整**，则采用**指针碰撞**的分配方式；如果**Java堆不规整**，则采用**空闲列表**的分配方式。而Java堆是否规则，与所采用的垃圾收集器是否带有空间压缩整理的能力决定。例如 Serial、ParNew等带压缩整理过程的收集器 ，采用指针碰撞； CMS这种基于清除(Sweep)算法的收集器 ，采用空闲列表。
<a name="JMZ6E"></a>
##### 2.3.2 对象的内存布局
在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为**三个部分**：**对象头**(Header)，**实例数据**(Instance Data)和**对齐填充**(Padding)。<br />HotSpot虚拟机对象的**对象头部分包括两类信息**。**第一类是用于存储对象自身的运行时数据**，如哈希码，GC分代年龄，锁状态标志，线程持有锁等，对象头的**另一部分是类型指针**，即**对象指向它的类型元数据的指针，**Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息不一定要经过对象本身。此外，如果对象是一个Java数据，那在对象头中还必须要有一块用于记录数组长度是数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。<br />接下来**实例数据部分**是**对象真正存储的有效信息**，即我们在程序代码里面锁定义的各种类型的字段内容，无论是从**父类继承**下来的，还是在**子类定义**的**字段都必须记录**。相同宽度的字段总是被分配到一起，在满足这个条件下，父类定义的变量会出现在子类之前。<br />第三部分是**对齐填充**，这不是必然存在的，仅仅起着占位符的作用， 由于HotSpot虚拟机的⾃动内存管理系统要求**对象起始地址必须是8字节的整数倍**，换句话说就是任何对象的大小都必须是8字节的整数倍，对齐填充用于**保证对象实例数据部分对齐**。
<a name="pKqnM"></a>
##### 2.3.3 对象的访问定位
创建对象是为了后续使用该对象，Java程序会通过栈上的reference数据来操作堆上的具体对象，而**reference类型只是一个指向对象的引用**，对象的访问方式由虚拟机实现而定，主流的访问方式有**使用句柄**和**直接指针**。<br />**句柄访问**：Java堆中将可能会划分出一块内存来作为**句柄池**，**reference中存储的就是对象的句柄地址**，而**句柄**中包含了**对象实例数据与类型数据各自具体的地址信息**。正如上面在方法区中所说，**使用一个类创建对象实例的过程中，JVM需要从方法区中加载并初始化该类的相关信息**。只有当类的信息准备完毕后，才能够创建出相应的对象实例并执行相应的操作。所以在这里句柄需要包含类型数据和对象实例数据各自的具体地址<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683190844810-7469f28c-c7ed-4489-9285-741eb6a78c5f.png#averageHue=%23f4f4f4&clientId=u43461ecb-0ed8-4&from=paste&height=335&id=u402de715&originHeight=587&originWidth=1166&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=210415&status=done&style=none&taskId=ue977b242-5873-4324-8e14-d08afe6412c&title=&width=666.2857142857143)<br /> 	**直接指针访问**：如果使用直接指针访问，Java堆中的对象的内存布局就必须考虑**如何放置访问类型数据的相关信息**，**reference中存储的直接就是对象地址**，**如果只是访问对象本身**，就**不需要多一次间接访问的开销**<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683191071678-7eba8a53-97a4-45e1-926c-99a011da33d2.png#averageHue=%23f5f5f5&clientId=u43461ecb-0ed8-4&from=paste&height=336&id=ue2c8f59b&originHeight=588&originWidth=1169&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=184244&status=done&style=none&taskId=uc1790cab-75b0-4f77-8efe-f588e47eb89&title=&width=668)<br />两种访问方式各有优势，使用**句柄访问**的好处是**reference中存储的是稳定句柄地址，在对象被移动时，只会改变句柄中的实例数据指针，不会改变reference本身**；使用**直接指针访问**的好处是**速度更快**，**节省了一次指针定位的开销**。HotSpot主要使用直接指针访问。

<a name="HLi34"></a>
### 第3章 垃圾收集器与内存分配策略
<a name="f0cCI"></a>
#### 3.1 概述
垃圾回收需要完成三件事：<br />1.哪些内存需要回收？<br />2.什么时候回收？<br />3.如何回收？<br />在第2章中，我们已经了解了Java内存的运行时数据区，其中程序计数器，虚拟机栈，本地方法栈是属于线程隔离的，这3个区域随线程而生，随线程而灭。而在Java的堆区和方法区中有些明显的不确定性，只有在运行期间我们才能知道程序会创建哪些对象，创建多少个对象，这部分内存的分配和回收时动态的，垃圾收集器关注的正式这部分内存应该如何管理。
<a name="QQCEQ"></a>
#### 3.2 对象已死?
<a name="t2cMk"></a>
##### 3.2.1 引用计数算法
很多教科书判断对象是否存活的算法时这样的：在对象中添加一个**引用计数器**，每当**有一个地方引用它时**，**计数器值就加一**；**当引用失效时**，**计数器值就减一**；任何时刻**计数器为零的对象就是不可能再被使用的**。<br />引用计数算法虽然占用了一些额外的内存空间内来计数，但它的原理简单，判定效率也很高，但也有其缺点，譬如**单纯的引用计数就很难解决对象之间相互循环引用的问题**。例如两个对象相互引用对方，导致它们的引用计数都不为零，引用计数算法也就无法回收它们。
<a name="ZKxBA"></a>
##### 3.2.2 可达性分析算法
当前主流的商用程序语言的内存管理子系统，都是通过可达性分析算法来判定对象是否存活的。这个算法的基本思路就是通过一系列称为"GC Roots" 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为"引用链"，如果某个对象到GC Roots间没有任何引用链相连，则证明此对象时不可能再被使用的<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683192069701-682fd960-cda8-49d1-b22b-38722b3e4bf4.png#averageHue=%23f6f6f6&clientId=u43461ecb-0ed8-4&from=paste&height=523&id=u31300ebe&originHeight=915&originWidth=1173&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=230040&status=done&style=none&taskId=ub7ea9cab-3234-4945-9de7-26761359450&title=&width=670.2857142857143)<br />在Java技术体系中，固定可作为GC Roots的对象包括以下几种：<br />·在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等<br />·在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量<br />·在方法区中常量引用的对象，譬如字符串常量池里的引用<br />·在本地方法栈中JNI引用的对象<br />·Java虚拟机内部的引用<br />·所有被同步锁持有的对象<br />·反应Java虚拟机内部情况的JMXbean等
<a name="famVx"></a>
##### 3.2.3 再谈引用
在JDK1.2版本之后，Java对引用的概念进行了扩充，将引用分为**强引用，软引用，弱引用和虚引用。**<br />**强引用**是**最传统的引用的定义**，是指在程序代码之中普遍存在的引用赋值。在任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收被引用的对象。<br />**软引用**是用来描述**一些还有用但非必须的对象**。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围中进行第二次回收。<br />**弱引用**也是用来描述**那些非必须对象**，但它的强度比软引用更弱，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。<br />**虚引用**也称为"幽灵引用"或者"幻影引用"，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响
<a name="VXWsp"></a>
##### 3.2.4 生存还是死亡?
即使在可达性分析算法中判定为不可达的对象，也不是非死不可，这时它们暂时还处于缓刑阶段，宣告一个对象真正死亡，需要至少经历两次标记过程： 如果对象在进行可达性分析后发现**没有与GC Roots相连接的引用链**，那它将会被**第一次标记**，**随后进行一次筛选**，筛选的条件是**此对象是否有必要执行finalize()方法**。假如对象**没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过**，那么虚拟机将这两种情况都视为“**没有必要执行**“。<br /> 如果这个对象被判定为**确有必要执行finalize()方法**，那么该对象将会被**放置在一个名为F-Queue的队列之中**，并在稍后由一条由虚拟机自动建立的、低调度优先级的**Finalizer线程去执行它们的finalize() 方法**。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但**并不承诺一定会等待它运行结束**。 这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导 致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。finalize()方法是对 象逃脱死亡命运的最后一次机会，稍后**收集器将对F-Queue中的对象进行第二次小规模的标记**，如果**对象要在finalize()中成功拯救自己**——只要**重新与引用链上的任何一个对象建立关联即可**，譬如把自己 （this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；**如果对象这时候还没有逃脱，那基本上它就真的要被回收了 。**
<a name="LAEYR"></a>
##### 3.2.5 回收方法区
方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用是类型。回收废弃常量与回收Java堆中的对象非常类似。判定一个常量是否"废弃"相对简单，而要判定一个类型是否属于"不再被使用的类"的条件就比较苛刻。需要同时满足下面三个条件：<br />1.该类的**所有实例都已经被回收**<br />2.加载该类的**类加载器已经被回收**<br />3.该类对应的**java.lang.Class对象没有在任何地方被引用**，无法在任何地方通过反射访问该类的方法。

<a name="K4x2p"></a>
#### 3.3 垃圾收集算法
 从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”（Reference Counting GC）和"追踪式垃圾收集" (Tracing GC）两大类，这两类也常被称作“直接垃圾收集”和“间接垃圾收集”。由于引用计数式垃圾收集算法在本书讨论到的主流Java虚拟机中均未涉及，所以我们暂不 把它作为正文主要内容来讲解，**本节介绍的所有算法均属于追踪式垃圾收集的范畴** 。
<a name="uHeKp"></a>
##### 3.3.1 分代收集理论
当前商业虚拟机的垃圾收集器，大多数遵循了"分代收集"的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：<br />1.**弱分代假说：绝大多数对象都是朝生夕灭**<br />2.**强分代假说：熬过越多次垃圾收集过程的对象就越难消亡**<br />把分代收集理论具体放到现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为新生代(Young Generation)和老年代(Old Generation)两个区域。顾名思义，在新生代中，每次垃圾收集时都会有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。<br />加入现在要进行一次只局限于新生代区域内的收集(Minor GC)，但是新生代中的对象时完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。为了解决这个问题，就需要对分代收集理论添加第三条经验法则：<br />3.**跨代引用假说：跨代引用相对于同代引用来说仅占极少数**<br />这其实时可根据前两条假说逻辑推理得出的隐含推论：存在互相引用关系的两个对象，应该倾向于同时生存或者同时消亡的。<br />依据这条假说，我们就不应该再为了少量的跨代引用区扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需要在**新生代**上建立一个**全局的数据结构**(该结构被称为**"记忆集"**)，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系时维护记录数据的正确性，会增加一些运行时开销，但比起收集时扫描整个老年代来说任然时划算的。<br /> ·**部分收集**（Partial GC）：指目标不是完整收集整个Java堆的垃圾收集，其中又分为： <br />1.新生代收集（Minor GC/Young GC）：指目标只是新生代的垃圾收集。 <br />2.老年代收集（Major GC/Old GC）：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单 独收集老年代的行为。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指， 读者需按上下文区分到底是指老年代的收集还是整堆收集。 <br />3.混合收集（Mixed GC）：指目标是收集整个新生代以及部分老年代的垃圾收集。**目前只有G1收集器会有这种行为**。 <br />·**整堆收集**（Full GC）：收集整个Java堆和方法区的垃圾收集。

<a name="XzHeY"></a>
##### 3.3.2 标记-清除算法
最早出现也是最基础的垃圾收集算法时**“标记-收集算法”**(Mark-Sweep)算法，算法分为**标记**和**清除**两个阶段：<br />首先**标记出所有需要回收的对象**，在标记完成后，统一回收掉所有被标记的对象，也**可以反过来**，**标记存活的对象**，同意回收所有未被标记的对象。标记过程就是对象是否属于垃圾的判定过程。<br />它主要的**缺点**有两个：<br />1.**执行效率不太稳定**，如果Java堆中包含大量对象，而且其中大部分时需要回收的这时候需要进行大量的标记和清除操作，这两个操作过程的**执行效率都是随着对象数量的增长而降低**<br />2.**对象碎片化问题**，标记清除后会产生大量的不连续的内存碎片，空间碎片太多可能导致以后在程序运行时，需**要分配大内存对象无法找到足够的连续内存空间而不得不进行另一次垃圾收集动作**。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683195745166-5f8d2523-cf7d-43ee-abd6-48f1799b8f3d.png#averageHue=%23f8f6f2&clientId=u43461ecb-0ed8-4&from=paste&height=395&id=u1e591efe&originHeight=692&originWidth=1154&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=113800&status=done&style=none&taskId=ud178762b-508d-41cf-bf38-205289bb10a&title=&width=659.4285714285714)
<a name="Czju0"></a>
##### 3.3.3 标记-复制算法
标记-复制算法被简称为复制算法。为了解决标记清除算法面对大量可回收对象时执行效率低的问题，1969年Fenichel提出了一种“半区复制“的垃圾回收算法，它**将可用的内存按容量大小分为相等的两块**，每次只使用其中的一块。**当这一块的内存用完了，将还活着的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉**。<br />如果内存中**多数对象时存活**的，这种算法也会**产生大量的内存间复制开销**，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对半区进行回收，**分配内存时就不用考虑有空间碎片的复杂情况**，只需要移动堆顶指针，按顺序分配。不过这种**算法的缺陷**也是显而易见的，将**可用内存缩小为原来的一半**，**浪费了太多的内存空间**<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683196320888-48bdd4a2-b099-41cb-b6cf-0d45554508bb.png#averageHue=%23efefef&clientId=u43461ecb-0ed8-4&from=paste&height=382&id=uedfb3b93&originHeight=668&originWidth=1159&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=117283&status=done&style=none&taskId=u8007f36b-07b9-4af5-8e33-fcde0a1571f&title=&width=662.2857142857143)<br />现在的商用Java虚拟机大多优先采用这种收集算法去回收新生代<br />在1989年，Andrew Appel提出了一种更优化的半区复制分代策略，称为**"Appel式回收"**。**HotSpot虚拟机的Serial，ParNew等新生代收集器**均采用这种策略来设计新生代的内存布局。<br />**Appel式回收**是把**新生代**分为**一块较大的Eden空间和两块较小的Survivor空间**，每次**分配内存只是用Eden和其中一块Survivor**。发生垃圾收集时，**将Eden和Survivor中仍然存活的对象一次性复制到另一块Survivor空间上**，然后**直接清理掉Eden和已用过的那块Survivor空间**。HotSpot虚拟机默认的Eden和Survivor的大小比例是8:1。不过任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的**”逃生门“**的安全设计，**当Survivor空间不足以容纳下一次Minor GC之后存活的对象时，就需要依赖其他内存区域进行分配担保**(多数情况下式老年代)。
<a name="t8hs6"></a>
##### 3.3.4 标记-整理算法
标记-复制算法在存活对象较多时需要进行较多的赋值操作，导致效率降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，而一般进行分配担保的就是老年代，所以在老年代一般不直接选用这种算法。<br />针对老年代对象的存亡特征，提出了另一种有针对性的”标记-整理“算法，其标记过程仍然与”标记-清除“算法一样，但后续步骤不是直接对可回收对象清理，而是让所有存活对象都向内存空间一端移动，然后直接清理掉边界以外的内存。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683197215605-81486bad-cff3-48f3-9a83-8f1213669753.png#averageHue=%23f8f6f2&clientId=u43461ecb-0ed8-4&from=paste&height=400&id=u847abdd8&originHeight=700&originWidth=1199&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=110214&status=done&style=none&taskId=u20faa0de-7e23-4c34-8b1a-0fe204e9eff&title=&width=685.1428571428571)<br />如果移动存活对象，尤其是在**老年代这种每次回收都有大量对象存活区域**，移动存活对象并更新所有引用这些对象的地方是一种**极为负重的操作**，而且这种**对象移动**操作必须**全程暂停用户应用程序**才能进行。<br />但如果跟标记-清除算法那样完全**不考虑移动和整理存活对象的话**，弥散于堆中的存活对象导致的**空间碎片化问题**只能**依赖更为复杂的内存分配器和内存访问器来解决**。譬如通过**内存分配链表**来解决内存分配问题。内存的访问是用户程序最频繁的操作，如果在这个环节上增加了额外的负担，势必会直接影响程序的吞吐量。<br />总的来说，是否移动对象都存在在弊端，**移动**则会在**内存回收时更复杂**，**不移动**则会在**内存分配时更复杂。**从**垃圾收集的停顿时间**来看，**不移动对象停顿时间更短**，但是从**整个程序的吞吐量来看**，**移动对象会更划算**。<br />而在HotSpot虚拟机中，关注**吞吐量的Parallel Scavenge收集器**采用的是**标记-复制**算法，而**标记-复制算法中存在一个整理的过程**，会更优于吞吐量；而**关注回收停顿时间的CMS收集器**采用的是**标记-清除**算法，可以**减少垃圾收集的停顿时间。**
<a name="I0ajh"></a>
#### 3.4  HotSpot的算法细节实现
<a name="fPa1O"></a>
##### 3.4.1 根节点枚举
 我们以可达性分析算法中从GC Roots集合找引用链这个操作作为介绍虚拟机高效实现的第一个例子。 所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的。<br />在HotSpot的解决方案里，使用一组称为**OopMap的数据结构**来**直接得到哪些地方存放着对象的引用**。一旦**类加载动作完成**的时候，HotSpot就会把**对象内什么偏移量上是上面类型的数据计算出来**，也会在**特定位置**记录下**栈里和寄存器里哪些位置是引用**。这样**收集器在扫描时就可以直接得知这些信息**，不需要真正一个不漏从方法区等GC Roots开始查找。  
<a name="TZCbH"></a>
##### 3.4.2 安全点
在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但如果为每一条指令都生成对应的OopMap，会需要大量的额外存储空间。实际上HotSpot没有为每条指令都生成OopMap，前面已经提到，只是在特定的位置记录这些信息，这些位置被称为安全点。有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。
<a name="IuMnz"></a>
##### 3.4.3 安全区域
 安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。但是，**程序“不执行”的时候**呢？所谓的程序不执行就是没有分配处理器时间， 这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。对于这种情况，就必须引入安全区域（Safe Region）来解决。<br /> **安全区域**是指**能够确保在某一段代码片段之中，引用关系不会发生变化**，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把**安全区域看作被扩展拉伸了的安全点**。
<a name="GZBRN"></a>
##### 3.4.4 记忆集与卡表
**记忆集**是一种用于**记录从非收集区域指向收集区域的指针集合的抽象数据结构**。如果我们不考虑效率和成本的话，最简单的实现可以**用非收集区域中所有含跨代引用的对象数组**来实现这个数据结构。在垃圾收集的场景中，**收集器**只需要**通过记忆集判断出一块非收集区域中是否存在有指向了收集区域的指针就可以**了，并不需要了解这些跨代指针的全部细节。<br />字长精度：每个记录精确到一个机器字长，该字包含跨代指针<br />对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针<br />卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针<br />其中，第三种**卡精度**所指的是**用一种称为“卡表”的方式**去**实现记忆集**，**卡表**最简单的形式可以**只是一个字节数组**，而**HotSpot虚拟机**确实也是这样做的<br />字节数组CARD_TABLE的每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块被称作"卡页"。![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683200228612-88bba674-70b0-4313-9a26-439c0b785acb.png#averageHue=%23e3c597&clientId=u43461ecb-0ed8-4&from=paste&height=591&id=u7786eb97&originHeight=1035&originWidth=939&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=197295&status=done&style=none&taskId=u6ba67763-162c-4727-a815-b4e526dde33&title=&width=536.5714285714286)<br />一个卡页中通常包含不止一个对象，只要**卡页内有一个或更多对象的字段存在着跨代指针**，那就将**对应的卡表**的**数组元素**的**值标识为1**，称为这个元素变脏(Dirty)，没有则标识为0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易的得出哪些卡页内存块中包含跨代指针，把它们加入GC Roots中一并扫描。
<a name="kmWRd"></a>
##### 3.4.5 写屏障
**卡表元素**在**有其他分代区域中的对象引用了本区域对象时，其对应的卡表元素就变脏**，变脏的时间点原则上应该发生在引用类型字段赋值的那一刻，但是如何变脏呢？<br />在**HotSpot虚拟机**里是通过**写屏障技术**维护卡表状态。写屏障可以看作在虚拟机层面对”引用类型字段赋值“这个动作的AOP切面，在引用对象赋值时产生一个环形通知，供程序执行额外的动作，也就是说**赋值的前后都在写屏障的覆盖范畴内**。在**赋值前的部分的写屏障**叫作**写前屏障**（Pre-Write Barrier），在**赋值后**的则叫作**写后屏障**（Post-Write Barrier）。HotSpot虚拟机的许多收集器中都有使用到写屏障，但直至G1收集器出现之前，其他收集器都只用到了写后屏障。
<a name="QjL6g"></a>
##### 3.4.6 并发的可达性分析
包含**标记**阶段是所有**追踪式垃圾收集算法的共同特征**，如果这个阶段随着堆变大而等比例增加停顿时间，那将会影响几乎所有的垃圾收集器。<br />想解决或者降低用户线程的停顿，先搞清楚为什么必须在一个能保证一致性的快照上才能进行对象图的遍历？为了解释这个问题，我们引入**三色标记**<br />·**白色**：表示**对象尚未被垃圾收集器访问过**。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。 <br />·**黑色**：表示**对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过**。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接（不经过灰色对象）指向某个白色对象。 <br />·**灰色**：表示**对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过**。  <br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683201325878-37bc0cc0-f1ee-4d74-b128-b84c8d183773.png#averageHue=%23f4f4f4&clientId=u43461ecb-0ed8-4&from=paste&height=630&id=u43e62bf6&originHeight=1103&originWidth=1073&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=463924&status=done&style=none&taskId=uef254ef1-1db9-48a3-b0d3-07b5ba7e18c&title=&width=613.1428571428571)<br /> Wilson于1994年在理论上证明了，**当且仅当以下两个条件同时满足时**，会产生“对象消失”的问题，即**原本应该是黑色的对象被误标为白色**：<br />·赋值器**插入了一条或多条从黑色对象到白色对象的新引用**； <br />·赋值器**删除了全部从灰色对象到该白色对象的直接或间接引用**。<br /> 我们要解决并发扫描时的对象消失问题，只需**破坏这两个条件的任意一个即可**。由此分别产生了两种解决方案：<br />**增量更新**（Incremental Update）<br />**原始快照**（Snapshot At The Beginning， SATB）。

**增量更新**破环的是**第一个条件**，当**黑色对象插入**新的指向白色对象的引用关系时，就**将这个新的插入引用记录下来**，在**并发扫描结束**后，再将这些**记录过的引用关系中的黑色对象为根，重新扫描一次**。<br />可以简化理解为：黑色对象一旦新插入了指向白色对象的引用后，它就变回灰色对象<br />**原始快照**破坏的是**第二个条件**，当**灰色对象要删除**指向白色对象的引用关系时，就将这个**要删除的引用记录下来**，在**并发扫描结束**后，将这些**记录过的引用关系中的灰色对象为根，重新扫描一次**。<br />可以简化理解为：无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索<br /> 以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过**写屏障**实现的。在 HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，**CMS**是基于**增量更新**来做并发标记的，**G1、Shenandoah**则是用**原始快照**来实现。
<a name="oqTee"></a>
#### 3.5 经典垃圾收集器
 各款经典收集器之间的关系 如图3-6所示  <br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683359369407-238867aa-8082-4fd8-bae0-8944db6a07b3.png#averageHue=%23e3e3e3&clientId=u5ac6de6a-b83a-4&from=paste&height=620&id=u961c2a2a&originHeight=1085&originWidth=1057&originalType=binary&ratio=1.5899999141693115&rotation=0&showTitle=false&size=288372&status=done&style=none&taskId=ubefe33e4-71e6-463b-87b2-6bdd482bd15&title=&width=604.3453563413857)
<a name="r7gTZ"></a>
##### 3.5.1 Serial收集器
Serial收集器是最基础，历史最悠久的收集器，曾经是HotSpot虚拟机新生代收集器的唯一选择。这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或者一条收集线程去完成垃圾收集工作，更重要的是强调它在进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。简称为"STW"。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683365344473-a3043b3a-af64-41be-9331-265f451f2883.png#averageHue=%23f6f6f6&clientId=u5ac6de6a-b83a-4&from=paste&height=164&id=u65ef96ba&originHeight=286&originWidth=1075&originalType=binary&ratio=1.5899999141693115&rotation=0&showTitle=false&size=129248&status=done&style=none&taskId=u28521822-3098-4746-9098-d00ec69d0f5&title=&width=614.6369518136137)<br /> 迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的**默认新生代收集器**，有着优于其他收集器的地方，那就是**简单而高效**（与其他收集器的单线程相比），对于内存资源受限的环境，它是所有收集器里额外内存消耗（Memory Footprint）最小的；**对于单核处理器或处理器核心数较少的环境**来说，**Serial收集器**由于**没有线程交互的开销**，专心做垃圾收集自然可以获得最高的单线程收集效率。
<a name="saEFx"></a>
##### 3.5.2 ParNew收集器
ParNew收集器实质上是Serial收集器的多线程并行版本，同时使用多条线程进行垃圾收集，两种收集器共用了相当多的代码。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683438821399-34793816-c6da-44b1-a89a-d922feb80ff9.png#averageHue=%23f3f3f3&clientId=ucb0eae41-9b16-4&from=paste&height=178&id=ud42274bb&originHeight=312&originWidth=1185&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=164802&status=done&style=none&taskId=ud7e88ca7-fe8d-4d8d-926f-c0cf594fc88&title=&width=677.1428571428571)<br /> **ParNew收集器**除了**支持多线程并行收集**之外，其他与Serial收集器相比并没有太多创新之处，但它却是不少运行在**服务端模式**下的HotSpot虚拟机，尤其是JDK 7之前的遗留系统中**首选的新生代收集器**，其中有一个与功能、性能无关但其实很重要的原因是：**除了Serial收集器外，目前只有它能与CMS收集器配合工作**。  <br />在**JDK5版本发布后**，HotSpot采用CMS收集器来收集老年代的垃圾，新生代只能选择ParNew或者Serial收集器其中的一个，ParNew是激活CMS后的默认新生代收集器。<br />直到CMS出现才巩固的ParNew的地位，但是由于更先进的G1收集器出现，它不再需要其他新生代收集器的配合工作。**从JDK9开始**，ParNew+CMS组合就已经不再是官方推荐的服务端模式下的收集器解决方案了。官方希望它被G1取代，取消了ParNew+Serial Old 以及Serial+CMS这两组收集器组合，也就是说**ParNew只能和CMS搭配使用**。<br />· **并行（Parallel）**：并行描述的是**多条垃圾收集器线程之间的关系**，说明同一时间有多条这样的线程在协同工作，通常默认**此时用户线程是处于等待状态**。 <br />· **并发（Concurrent）**：并发描述的是**垃圾收集器线程与用户线程之间的关系**，说明**同一时间垃圾收集器线程与用户线程都在运行**。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。
<a name="Xld6I"></a>
##### 3.5.3 Parallel Scavenge收集器
 **Parallel Scavenge收集器**也是一款**新生代收集器**，它同样是基于**标记-复制算法**实现的收集器，也是**能够并行收集的多线程收集器**。 Parallel Scavenge收集器的**特点是它的关注点与其他收集器不同**，**CMS等收集器**的关注点是尽可能地**缩短垃圾收集时用户线程的停顿时间**，而**Parallel Scavenge收集器**的目标则是**达到一个可控制的吞吐量**(Throughput)。所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值，即：  <br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683439435529-46af4ba3-3dcf-443c-821c-2eb7f7c0cee9.png#averageHue=%23f2f2f2&clientId=ucb0eae41-9b16-4&from=paste&height=110&id=u975212b0&originHeight=192&originWidth=1129&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=90822&status=done&style=none&taskId=u277c2832-c3f7-4be5-9bdf-bf825ad4216&title=&width=645.1428571428571)<br /> 如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。**停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序**，良好的响应速度能提升用户体验；而**高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务**，主要适合在后台运算而不需要太多交互的分析任务。  <br /> 由于与吞吐量关系密切，Parallel Scavenge收集器也经常被称作“**吞吐量优先收集器**”。除上述两个参数之外，Parallel Scavenge收集器还有一个参数-XX：+UseAdaptiveSizePolicy值得我们关注。这是一个开关参数，当这个参数被激活之后，就**不需要人工指定**新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数 了，虚拟机会根据当前系统的运行情况收集性能监控信息，**动态调整**这些参数以提供最合适的停顿时间或者最大的吞吐量。这种调节方式称为**垃圾收集的自适应的调节策略**（GC Ergonomics）。  
<a name="eDLVU"></a>
##### 3.5.4 Serial Old收集器
 Serial Old是Serial收集器的**老年代版本**，它同样是一个**单线程收集器**，使用**标记-整理算法**。这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。如果在服务端模式下，它也可能有两种用途：一种是在**JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用**，另外一种就是作为**CMS收集器发生失败时的后备预案**，在并发收集发生Concurrent Mode Failure时使用。  <br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683439856400-238f11a9-2a43-4ad6-90cc-43fbb6cbe974.png#averageHue=%23f4f4f4&clientId=ucb0eae41-9b16-4&from=paste&height=170&id=uc04a1460&originHeight=297&originWidth=1168&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=145553&status=done&style=none&taskId=u2d826857-711c-47cb-8fcd-13d5a92372f&title=&width=667.4285714285714)
<a name="JAsaA"></a>
##### 3.5.5 Parallel Old收集器
 **Parallel Old是Parallel Scavenge收集器的老年代版本**，支持**多线程并发收集**，基于**标记-整理算法**实现。这个收集器是直到JDK 6时才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于相当尴尬的状态，原因是如果**新生代选择了Parallel Scavenge收集器**，老年代**除了Serial Old**（PS MarkSweep）收集器**以外别无选择**，其他表现良好的老年代收集器，如CMS无法与它配合工作。由于老年代**Serial Old收集器在服务端应用性能上的“拖累”**，使用Parallel Scavenge收集器也**未必能在整体上获得吞吐量最大化的效果**。  <br /> 直到Parallel Old收集器出现后，“**吞吐量优先**”收集器终于有了比较名副其实的搭配组合，在**注重吞吐量或者处理器资源较为稀缺的场合**，都可以**优先考虑Parallel Scavenge加Parallel Old收集器**这个组合。 <br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683440191459-c505b391-0764-436f-a7c1-acbb3f2baa36.png#averageHue=%23f3f2f2&clientId=ucb0eae41-9b16-4&from=paste&height=177&id=u546fac5c&originHeight=309&originWidth=1175&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=170874&status=done&style=none&taskId=u5e3fa0b0-71b8-44a8-8bdf-1cb2f87b979&title=&width=671.4285714285714)
<a name="N8t8Y"></a>
##### 3.5.6 CMS收集器
 **CMS（Concurrent Mark Sweep）收集器**是一种以获取**最短回收停顿时间**为目标的收集器。目前很大一部分的Java应用集中在互联网网站或者基于浏览器的B/S系统的服务端上，这类应用通常都会较为关注服务的响应速度，希望系统停顿时间尽可能短，以**给用户带来良好的交互体验**。CMS收集器就非常符合这类应用的需求。<br /> 从名字（包含“Mark Sweep”）上就可以看出CMS收集器是**基于标记-清除算法**实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为**四个步骤**，包括： <br />1）**初始标记**（CMS initial mark） <br />2）**并发标记**（CMS concurrent mark） <br />3）**重新标记**（CMS remark） <br />4）**并发清除**（CMS concurrent sweep）<br />其中**初始标记**和**重新标记**两个步骤需要**STW**。<br />**初始标记**仅仅是**标记一下GC Roots能直接关联到的对象**，速度很快<br />**并发标记**是从**GC Roots的直接关联对象开始遍历整个对象图的过程**，这个阶段耗时较长但**不需要停顿用户线程**，可以**与垃圾收集线程并发运行**<br />**重新标记**阶段是为了**修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录**，这个阶段停顿时间通常会比初始标记阶段长一些，但远比并发标记阶段时间短<br />**并发清除**是**清理删除掉标记阶段判断死亡的对象**，由于是基于**标记-清除**算法，所以**不需要移动存活对象**，正如前面所说，**不移动存活对象**，虽然会导致空间碎片化的问题，在内存分配时会产生其他问题，但是它**停顿的时间更短**，且这个阶段是**可以与用户线程并发运行**的，符合了**CMS关注最短回收停顿时间的目标**。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683440824490-0f35fc21-53ed-43bf-a2ab-75495e2220ff.png#averageHue=%23e3e0da&clientId=ucb0eae41-9b16-4&from=paste&height=162&id=u035dadf2&originHeight=284&originWidth=1164&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=224264&status=done&style=none&taskId=ued3e4abc-3de2-43ba-a348-968cfab825a&title=&width=665.1428571428571)<br /> **CMS**是一款优秀的收集器，它最主要的优点在名字上已经体现出来：**并发收集、低停顿**，一些官方公开文档里面也称之为“**并发低停顿收集器**”（Concurrent Low Pause Collector）。CMS收集器是 HotSpot虚拟机追求低停顿的第一次成功尝试，但是它还远达不到完美的程度，至少有以下**三个明显的缺点**：

1. **CMS收集器对处理器资源非常敏感**。事实上，面向并发设计的程序都对处理器资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低总吞吐量。
2. **CMS收集器无法处理“浮动垃圾”**，有可能出现 “Con-current Mode Failure”失败进而导致另一次完全“Stop The World”的Full GC的产生。在**CMS的并发标记和并发清理阶段**，**用户线程是还在继续运行的**，程序在运行自然就还会**伴随有新的垃圾对象不断产生**，但这一部分垃圾对象是出现在标记过程结束以后，**CMS无法在当次收集中处理掉它们**，只好留待**下一次垃圾收集时再清理掉**。**这一部分垃圾就称为“浮动垃圾”**。同样由于在垃圾收集阶段，用户线程还要持续运行，需要预留足够的内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待老年代几乎完全被填满了在再进行收集，必须预留一部分空间供并发收集时的程序运作。要是**CMS运行期间预留的内存无法满足程序分配新对象的需要**，就会出现一次“**并发失败**”， 这时候虚拟机将不得不启动后备预案：**冻结用户线程的执行**，**临时启用Serial Old收集器来重新进行老年代的垃圾收集**， 但这样停顿时间就很长了。
3. **CMS是基于”标记-清除“算法实现的收集器**，意味着**收集结束时会有大量空间碎片产生。空间碎片过多时，会给大对象分配带来很大的麻烦**，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配给当前对象，不得不触发一次Full GC的情况。 因此虚拟机设计者们还提供了另外一个参数-XX：CMSFullGCsBefore-Compaction（此参数从**JDK 9开始废弃**），这个参数的作用是**要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理**（默认值为0，表示每次进入Full GC时都进行碎片整理）。
<a name="v52Gj"></a>
##### 3.5.7 Garbage First收集器
Garbage First (G1) 收集器，是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部设计的思路和基于Region的内存布局形式。<br /> **G1**是一款主要**面向服务端应用的垃圾收集器**。HotSpot开发团队最初赋予它的期望是（在比较长期的）未来可以替换掉JDK 5中发布的CMS收集器。现在这个期望目标已经实现过半了，JDK 9发布之日，**G1宣告取代Parallel Scavenge加Parallel Old组合**，成为服务端模式下的默认垃圾收集器，而CMS则沦落至被声明为不推荐使用（Deprecate）的收集器。<br /> 在G1收集器出现之前的所有 其他收集器，包括CMS在内，垃圾收集的目标范围要么是整个新生代（Minor GC），要么就是整个老年代（Major GC），再要么就是整个Java堆（Full GC）。<br />而G1可以**面向堆内存任何部分来组成回收集**，**衡量标准**不再是它属于哪个分代，而是**哪块内存中存放的垃圾数量最多，回收收益最大**，这就是G1收集器的**Mixed GC模式**。<br />**G1开创**的**基于Region的堆内存布局**是它能够实现这个目标的关键。虽然G1仍是遵循分代收集理论设计的，但其堆内存的布局与其他收集器有非常明显的差异：**G1不再坚持固定大小以及固定数量的分代区域划分**，而是把**连续的Java堆划分为多个大小相等的独立区域(Region)**，每一个Region都可以**根据需要**，**扮演新生代的Eden空间，Survivor空间或者老年代空间**。收集器能够**对扮演不同角色的Region采用不同的策略去处理**，这样无论是新创建的对象还是已经存活了一段时间，熬过多次收集的旧对象都能获取很好的收集效果。<br />Region中还有一类**特殊的Humongous区域**，专门**用来存储大对象**。G1认为只要**超过了一个Region容量一半的对象即可判定为大对象**。每个Region的大小可以通过参数 -XX：G1HeapRegionSize设 定，取值范围为1MB～32MB，且应为2的N次幂。而对于那些超过了整个Region容量的超级大对象， 将会被**存放在N个连续的Humongous Region之中**，G1的大多数行为都把**Humongous Region作为老年代**的一部分来进行看待。<br />虽然**G1任然保留新生代和老年代的概念**，但**新生代和老年代不再是固定的，它们都是一系列区域的动态集合**。G1收集器之所以能够建立可预测的停顿时间模型，是应为它**将Region作为单次回收的最小单元**，即**每次收集到的内存空间都是Region大小的整数倍**，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。更具体的处理思路是**让G1收集器去跟踪各个Region里面垃圾堆积的“价值”大小**，**价值**即**回收所获得的空间大小以及回收所需时间的经验值**，然后在**后台维护一个优先级列表**，每次**根据用户设定允许的收集停顿时间**，**优先处理回收价值收益最大的那些Region**，这也就是"Garbage First"名字的由来。 这种使用**Region划分内存空间**，以及**具有优先级的区域回收方式**，保证了G1收集器在有限的时间内获取尽可能高的收集效率。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683442881951-bf0e6aa6-4d3e-441e-9dec-49e41d2fc070.png#averageHue=%23e7e7e7&clientId=ucb0eae41-9b16-4&from=paste&height=535&id=u077bf0fd&originHeight=937&originWidth=1149&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=149190&status=done&style=none&taskId=u83576bcd-edf1-49e0-9d6f-eaa8f375f3d&title=&width=656.5714285714286)<br /> G1收集器至少有以下这些关键的细节问题需要解决

1. 将Java堆分成多个独立的Region后，Region里面存在的跨Region引用对象如何解决？**使用记忆集避免全堆作为GC Roots扫描**，但在G1收集器上记忆集的应用其实要复杂很多，**每个Region都维护有自己的记忆集**，这些**记忆集会记录下别的Region指向自己的指针，并标记这些指针，分别在哪些卡页范围之内**。**G1的记忆集**在存储结构的本质上是一种**哈希表，Key是别的Region的起始地址**，**Value是一个集合**，里面存储的**元素**是**卡表的索引号**。这种“双向”的卡表结构（卡表是“我指向谁”，这种结构还记录了“谁指向我”）比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此**G1收集器要比其他的传统垃圾收集器有着更高的内存占用负担**。根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。
2. 在并发标记阶段如何保证收集线程与用户线程互不干扰地运行？这里首先要解决的是**用户线程改变对象引用关系时，必须保证其不能打破原本的对象图结构**，导致标记结果出现错误，该问题在前面以及说过解决方案，在**CMS**中采用的是**增量更新算法**，而在**G1**中是通过**原始快照算法**来实现的：

· 如图<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683443627798-de8136fa-0fc5-4797-971d-e35776cf5314.png#averageHue=%23eaeaea&clientId=ucb0eae41-9b16-4&from=paste&height=358&id=u789850a5&originHeight=627&originWidth=1077&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=187183&status=done&style=none&taskId=ua40f0607-8076-432f-8e16-f8e339d1ce5&title=&width=615.4285714285714)<br />此外，垃圾收集对用户线程的影响还体现在**回收过程中新创建对象的内存分配**上，程序要继续运行就肯定会持续有新对象被创建，**G1为每一个Region设计了两个名为TAMS(Top at Mark Start)的指针**，把**Region中的一部分空间划分出来用于并发回收过程中的新对象分配**，**并发回收时新分配的对象地址都必须在两个指针的位置上**。如果**内存回收的速度赶不上内存分配的速度**，G1收集器也要被迫**冻结用户线程执行**，导致**Full GC**而产生长时间的**STW**。<br /> 如果我们不去计算用户线程运行过程中的动作（如使用写屏障维护记忆集的操作），G1收集器的运作过程大致可划分为以下**四个步骤**： 

1.  **初始标记**（Initial Marking）：仅仅只是**标记一下GC Roots能直接关联到的对象**，**并且修改TAMS指针的值**，让下一阶段用户线程**并发运行**时，能**正确地在可用的Region中分配新对象**。这个阶段**需要停顿线程**，但**耗时很短**，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。 
2.  **并发标记**（Concurrent Marking）：从GC Root开始**对堆中对象进行可达性分析**，**递归扫描整个堆里的对象图，找出要回收的对象**，这阶段**耗时较长**，但**可与用户程序并发执行**。当对象图扫描完成以后，还要**重新处理原始快照(SATB)记录下的在并发时有引用变动的对象**。
3.  **最终标记**（Final Marking）：对用户线程做另一个**短暂的暂停**，用于**处理并发阶段结束后仍遗留下来的最后那少量的SATB记录**。
4. ** 筛选回收**（Live Data Counting and Evacuation）：负责**更新Region的统计数据**，**对各个Region的回收价值和成本进行排序**，根据用户所**期望的停顿时间**来**制定回收计划**，可以**自由选择任意多个Region构成回收集**，然后**把决定回收的那一部分Region的存活对象复制到空的Region中**，再**清理掉整个旧Region的全部空间**。这里的操作涉及**存活对象的移动**，是必须**暂停用户线程**，由**多条收集器线程**并行完成的。

从上述阶段的描述可以看出，**G1**收集器**除了并发标记外**，**其余阶段也是要完全暂停用户线程的**， 换言之，它**并非纯粹地追求低延迟**，官方给它设定的目标是**在延迟可控的情况下获得尽可能高的吞吐量**，所以才能担当起“全功能收集器”的重任与期望。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683444755169-6811288c-a402-4849-8767-a99afed79459.png#averageHue=%23e8e4dd&clientId=ucb0eae41-9b16-4&from=paste&height=178&id=u1d985cde&originHeight=312&originWidth=1171&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=238134&status=done&style=none&taskId=u54bc836b-1143-4388-ba0b-db29a07b460&title=&width=669.1428571428571)<br />由用户指定期望的停顿时间是G1收集器很强大的一个功能，但该期望时间也要符合实际，毕竟G1是要冻结用户线程来复制对象的，停顿时间再低也要有个限度。<br /> 相比CMS，G1的优点有很多，暂且不论可以**指定最大停顿时间**、**分Region的内存布局、按收益动态确定回收集这些创新性设计带来的红利**，单从最传统的算法理论上看，G1也更有发展潜力。与**CMS 的“标记-清除”算法**不同，**G1**从**整体来看是基于“标记-整理”算法**实现的收集器，但**从局部（两个Region 之间）上看又是基于“标记-复制”算法**实现，无论如何，这两种算法都意味着**G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存**。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。<br /> 不过，G1相对于CMS仍然不是占全方位、压倒性优势的，从它出现几年仍不能在所有应用场景中代替CMS就可以得知这个结论。比起CMS，G1的弱项也可以列举出不少，如在**用户程序运行过程**中，**G1**无论是为了**垃圾收集产生的内存占用**（Footprint）还是**程序运行时的额外执行负载** （Overload）都要**比CMS要高**。 例如在CMS和G1都是使用卡表来处理跨代指针，但是G1的卡表实现更为复杂，每一个Region区域都需要维护一份卡表，导致G1的记忆集可能占用整个堆容量20%甚至更多的内存空间。

<a name="OFLxb"></a>
#### 3.7 选择合适的垃圾收集器
<a name="b0MgT"></a>
##### 3.7.2 收集器的权衡
 应用程序的主要关注点是什么？如果是数据分析、科学计算类的任务，目标是能尽快算出结果， 那吞吐量就是主要关注点；如果是SLA应用，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点；而如果是客户端应用或者嵌入式应用，那垃圾收集的内存占用则是不可忽视的。  <br /> ·运行应用的基础设施如何？譬如硬件规格，要涉及的系统架构是x86-32/64、SPARC还是 ARM/Aarch64；处理器的数量多少，分配内存的大小；选择的操作系统是Linux、Solaris还是Windows 等。 <br />·使用JDK的发行商是什么？版本号是多少？是ZingJDK/Zulu、OracleJDK、Open-JDK、OpenJ9抑 或是其他公司的发行版？该JDK对应了《Java虚拟机规范》的哪个版本？ <br />一般来说，收集器的选择就从以上这几点出发来考虑。举个例子，假设某个直接面向用户提供服务的B/S系统准备选择垃圾收集器，一般来说延迟时间是这类应用的主要关注点，那么： <br />·如果你有充足的预算但没有太多调优经验，那么一套带商业技术支持的专有硬件或者软件解决方 案是不错的选择，Azul公司以前主推的Vega系统和现在主推的Zing VM是这方面的代表，这样你就可以 使用传说中的C4收集器了。 <br />·如果你虽然没有足够预算去使用商业解决方案，但能够掌控软硬件型号，使用较新的版本，同时 又特别注重延迟，那ZGC很值得尝试。 <br />·如果你对还处于实验状态的收集器的稳定性有所顾虑，或者应用必须运行在Win-dows操作系统 下，那ZGC就无缘了，试试Shenandoah吧。 <br />·如果你接手的是遗留系统，软硬件基础设施和JDK版本都比较落后，那就根据内存规模衡量一下，对于大概4GB到6GB以下的堆内存，CMS一般能处理得比较好，而对于更大的堆内存，可重点考察一下G1。  
<a name="ze7RY"></a>
#### 3.8 内存分配与回收策略

1. **对象优先在Eden分配**

 大多数情况下，对象在**新生代Eden区中分配**。当**Eden区没有足够空间进行分配**时，虚拟机将**发起一次Minor GC。** 

2. **大对象直接进入老年代**

大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组， 在Java虚拟机中要避免大对象的原因是，**在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集**，以获取足够的连续空间才能安置好它们，而**当复制对象时，大对象就意味着高额的内存复制开销**。HotSpot虚拟机提供了-XX：PretenureSizeThreshold 参数，**指定大于该设置值的对象直接在老年代分配**，这样做的目的就是**避免在Eden区及两个Survivor区之间来回复制**，产生大量的内存复制操作。    

3. ** 长期存活的对象将进入老年代**

 虚拟机给每个对象**定义了一个对象年龄（Age）计数器**，存储在**对象头**中（详见第2章）。对象通常**在Eden区里诞生**，如果**经过第一次 Minor GC后仍然存活**，并且能被**Survivor容纳**的话，该对象会**被移动到Survivor空间**中，并且将其**对象年龄设为1岁**。对象在Survivor区中每**熬过一次Minor GC**，**年龄就增加1岁**，当它的年龄**增加到一定程度**（默认为15），就会被**晋升到老年代中**。对象晋升老年代的年龄阈值，可以通过参数-XX： MaxTenuringThreshold设置。 

4. **动态对象年龄判定**

 为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到-XX：MaxTenuringThreshold才能晋升老年代，**如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代**，无须等到-XX： MaxTenuringThreshold中要求的年龄。  

5. **空间分配担保**

 在发生Minor GC之前，虚拟机**必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间**，如果这个条件成立，那这一次Minor GC可以确保是安全的。如果不成立，则虚拟机会先查看-XX：HandlePromotionFailure参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会**继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小**，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者-XX： HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。 <br />新生代使用**复制收集算法**，但为了内存利用率，只能**使用其中一个Survivor空间来作为轮换备份**，因此当出现大量对象在Minor GC后任然存活的情况——最极端的情况就是**内存回收后新生代中所有对象都存活**，需要**老年代进行分配担**保，把Survivor无法容纳的对象直接送入老年代，**老年代要进行这样的担保**，**前提**是老年代**本身还有容纳这些对象的剩余空间**， 但一共有多少对象会在这次回收中活下来在实际完成内存回收之前是无法明确知道的，所以只能取之前每一次回收晋升到老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。  
<a name="BTxKZ"></a>
### 第4章  虚拟机性能监控、故障处理工具  (保留)
<a name="hkt76"></a>
### 第5章  调优案例分析与实战  (保留)
<a name="e3gen"></a>
### 第6章  类文件结构
<a name="ZMCGu"></a>
#### 6.2 无关性的基石
 各种不同平台的Java虚拟机，以及所有平台都**统一支持的程序存储格式**——**字节码（Byte Code）**是构成平台无关性的**基石**。<br />**实现语言无关性的基础**仍然是**虚拟机**和**字节码存储格式**。Java虚拟机不与包括Java语言在内的任何程序语言绑定，它只与"Class文件"这种特定的二进制文件格式所关联，Class文件中包含了Java虚拟机指令集、符号表以及若干其他辅助信息。<br />《Java虚拟机规范》中要求在Class文件必须应用许多强制性的语法和结构化约束，但图灵完备的字节码格式，保证了任意一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。虚拟机只关心最终的存储字节码的Class文件，毫不关心Class的来源是什么语言。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683447314480-462606b0-0dbb-4e1b-be71-49573b6c8862.png#averageHue=%23f7f7f7&clientId=ucb0eae41-9b16-4&from=paste&height=418&id=u94a19d44&originHeight=732&originWidth=1170&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=215772&status=done&style=none&taskId=ua083c182-47c0-4c63-91a8-9ef1b50d649&title=&width=668.5714285714286)
<a name="UtCnm"></a>
#### 6.3 Class类文件的结构
 **任何一个Class文件**都**对应着唯一的一个类或接口的定义信息**，但是反过来说，类或 接口并不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）。本章中， 笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它完全不需要以磁盘文件的形式存在。 <br />** Class文件**是一组以**8个字节为基础单位**的**二进制流**，各个数据项目**严格按照顺序紧凑地排列在文件之中**，中间**没有添加任何分隔符**，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会**按照高位在前的方式分割成若干个8个字节进行存储**。  <br /> 根据《Java虚拟机规范》的规定，**Class文件格式**采用一种类似于C语言结构体的**伪结构来存储数据**，这种伪结构中**只有两种数据类型**：**“无符号数”和“表”**。  <br /> · **无符号数**属于**基本的数据类型**，以**u1、u2、u4、u8**来分别**代表1个字节、2个字节、4个字节和8个字节的无符号数**，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。 <br />· **表**是由**多个无符号数或者其他表作为数据项构成的复合数据类型**，为了便于区分，所有**表的命名**都习惯性地**以“_info”结尾**。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，这张表由表6-1所示的数据项按严格顺序排列构成。  <br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683447979494-27417c1a-1453-4eb1-9a24-7433deeea432.png#averageHue=%23e9e9e9&clientId=uf9c1202f-7004-4&from=paste&height=654&id=u568dbb1c&originHeight=1145&originWidth=867&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=309180&status=done&style=none&taskId=ue9e96b22-cb11-44a1-881e-120066f4063&title=&width=495.42857142857144)
<a name="DdWVj"></a>
##### 6.3.1 魔数与Class文件的版本
 每个**Class文件**的**头4个字节**被称为**魔数（Magic Number）**，它的**唯一作用**是**确定这个文件是否为一个能被虚拟机接受的Class文件**。不仅是Class文件，很多文件格式标准中都有使用魔数来进行身份识别的习惯，譬如图片格式，如GIF或者JPEG等在文件头中都存有魔数。**使用魔数而不是扩展名来进行识别主要是基于安全考虑**，因为文件扩展名可以随意改动。文件格式的制定者可以自由地选择魔数值，只要这个魔数值还没有被广泛采用过而且不会引起混淆。**Class文件的魔数**取得很有“浪漫气息”， 值为**0xCAFEBABE**（咖啡宝贝）  <br /> **紧接着魔数的4个字节**存储的是**Class文件的版本号**：**第5**和**第6**个字节是**次版本号（Minor Version）**，**第7**和**第8**个字节是**主版本号（Major Version）**。Java的版本号是从**45**开始的，JDK 1.1之后 的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），**高版本的JDK能向下兼容以前版本的Class文件**，但**不能运行以后版本的Class文件**，因为《Java虚拟机规范》在Class文 件校验部分明确要求了即使文件格式并未发生任何变化，**虚拟机也必须拒绝执行超过其版本号的Class文件**。  
<a name="b9EDw"></a>
##### 6.3.2 常量池
 紧接着主、次版本号之后的是**常量池入口**，常量池可以比喻为**Class文件里的资源仓库**，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在**Class文件**中**第一个出现的表类型数据项目**。  <br /> 由于常量池中**常量的数量是不固定的**，所以在**常量池的入口**需要**放置一项u2类型的数据**，代表**常量池容量计数值**（constant_pool_count）。与Java中语言习惯不同，这个容量计数是**从1而不是0开始**的，如图6-3所示，常量池容量（偏移地址：0x00000008）为十六进制数0x0016，即十进制的22，这就**代表常量池中有21项常量**，索引值范围为1～21。在Class文件格式规范制定之时，设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于，如果后面某些指向常量池的索引值的数据在**特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。**  <br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683448474974-e15bd13f-537e-48ae-a08d-ee68a153a3f1.png#averageHue=%23ecede9&clientId=uf9c1202f-7004-4&from=paste&height=152&id=u858e6e94&originHeight=266&originWidth=1106&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=303225&status=done&style=none&taskId=u59d59f96-c98c-4c16-bebe-220809be95c&title=&width=632)<br /> 常量池中主要存放两大类常量：<br />**字面量（Literal）和符号引用（Symbolic References）**。<br />**字面量**比较接近于**Java语言层面的常量概念**，如文本字符串、被声明为final的常量值等。<br />**符号引用**则属于**编译原理方面的概念**，主要包括下面几类常量： <br />· 被模块导出或者开放的**包**（Package） <br />· **类和接口的全限定名**（Fully Qualified Name） <br />· **字段的名称和描述符**（Descriptor） <br />· **方法的名称和描述符 **<br />· **方法句柄和方法类型**（Method Handle、Method Type、Invoke Dynamic）<br />· **动态调用点和动态常量**（Dynamically-Computed Call Site、Dynamically-Computed Constant） <br />Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是**在虚拟机加载Class文件的时候进行动态连接**（具体见第7章）。也就是说，**在Class文件中不会保存各个方法、字段最终在内存中的布局信息**，这些字段、方法的**符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址**，也就**无法直接被虚拟机使用的**。当虚拟机做**类加载**时，将会从**常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中**。  
<a name="WLVqQ"></a>
##### 6.3.3 访问标志
 在常量池结束之后，**紧接着的2个字节**代表**访问标志**（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个**Class是类还是接口**；**是否定义为public类型**；**是否定义为abstract类型**；如果**是类的话，是否被声明为final**；
<a name="GUI6H"></a>
### 第7章  虚拟机类加载机制
<a name="Tpkny"></a>
#### 7.1 概述
 Java虚拟机把**描述类的数据从Class文件加载到内存**，并对数据进行**校验**、**转换解析**和**初始化**，最终形成可以**被虚拟机直接使用的Java类型**，这个过程被称作虚拟机的**类加载机制**。与那些在编译时需要进行连接的语言不同，在Java语言里面，**类型的加载、连接和初始化过程都是在程序运行期间完成的**，这种策略让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销， 但是却为Java应用**提供了极高的扩展性和灵活性**，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。  <br />例如，编写一个面向接口的应用程序，可以等到运行时再指定其 实际的实现类，用户可以通过Java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络 或其他地方上加载一个二进制流作为其程序代码的一部分。 
<a name="xQqku"></a>
#### 7.2 类加载的时机
  一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历**加载 **（Loading）、**验证**（Verification）、**准备**（Preparation）、**解析**（Resolution）、**初始化** （Initialization）、**使用**（Using）和**卸载**（Unloading）七**个阶段**，其中**验证、准备、解析**三个部分**统称为连接（Linking）**。这七个阶段的发生顺序如图7-1所示 。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683449141268-328b0145-557c-4e61-8e87-22870595273c.png#averageHue=%23e9d7c1&clientId=uf9c1202f-7004-4&from=paste&height=233&id=u4826ec6b&originHeight=407&originWidth=1101&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=119746&status=done&style=none&taskId=ud6934356-e1d9-4151-82b7-d82f514d39f&title=&width=629.1428571428571)<br />图中，**加载，验证，准备，初始化和卸载**这五个阶段的**顺序是确定的**，类型的加载过程必须按照这种顺序按部就班地**开始**，而**解析阶段则不一样**：它的**某些情况下可以在初始化阶段之后再开始**，这是为了**支撑Java语言的运行时绑定特性**（也称为动态绑定或晚期绑定）。注意，这里说的是按部就班的**开始**，而**不是按部就班的进行或者完成**，强调这点是因为这些阶段**通常都是互相交叉地混合进行**，会在**一个阶段的执行过程中调用，激活另一个阶段。**<br />关于在什么情况下需要开始类加载过程的**第一个阶段“加载”**， 《Java虚拟机规范》中并**没有进行强制约束**，这点**可以交给虚拟机的具体实现来自由把握**。但是**对于初始化阶段**，《Java虚拟机规范》 则是**严格规定了有且只有六种情况必须立即对类进行“初始化”**（而**加载、验证、准备自然需要在此之前开始**）：

1.   遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。能够生成这四条指令的典型Java代码场景有：  

· 使用**new关键字**实例化对象的时候<br />· **读取或设置一个类型的静态字段**( 被final修饰、已在编译期把结果放入常量池的静态字段除外 )的时候<br />· **调用一个类型的静态方法的时候**

2. 使用**java.lang.reflect包的方法堆类型进行反射调用**的时候，如果类型没有初始化，则需要先触发其初始化
3. 当**初始化类**的时候，如果**发现其父类还没有进行初始化**，则需要**先触发其父类的初始化**
4. 当**虚拟机启动**时，用户需要指定一个**要执行的主类(包含main()方法的那个类)，虚拟机会先初始化这个主类**
5.  当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化 
6. **当一个接口**中定义了JDK 8新加入的**默认方法(被default关键字修饰的接口方法)**时，如果由这个接口的**实现类发生了初始化**，那该**接口要在其之前被初始化**

**接口的初始化：**<br /> 接口也有初始化过程， 这点与类是一致的，上面的代码都是用静态语句块“static{}”来输出初始化信息的，而**接口中不能使用“static{}”语句块**，但**编译器仍然会为接口生成“<clinit>()”类构造器**，用于**初始化接口中所定义的成员变量**。接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种： **当一个类在初始化时，要求其父类全部都已经初始化过了**，但是**一个接口在初始化**时，并**不要求其父接口全部都完成了初始化**，**只有在真正使用到父接口的时候**（如引用接口中定义的常量）**才会初始化**。 
<a name="hbscj"></a>
#### 7.3 类加载的过程
<a name="ARzR4"></a>
##### 7.3.1 加载
 **“加载”**（Loading）阶段是整个**“类加载”（Class Loading）过程中的一个阶段**。在加载阶段，Java虚拟机需要完成以下三件事情

1. 通过**一个类的全限定名**来获取**定义此类的二进制字节流**
2. 将这个**字节流所代表的静态存储结构**转化为**方法区的运行时数据结构**
3. **在内存中生成一个代表这个类的java.lang.Class对象**，作为**方法区这个类的各种数据的访问入口 **

相对于类加载过程的其他阶段，**非数组类型**的加载阶段 （准确地说，是加载阶段中**获取类的二进制字节流的动作**）是开发人员可控性最强的阶段。加载阶段**既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成**，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。<br />对于数组类而言，情况就有所不同，**数组类本身不通过类加载器创建**，它是由**Java虚拟机直接在内存中动态构造出来的**。但数组类与类加载器仍然有很密切的关系，因为**数组类的元素类型**（指的是**数组去掉所有维度的类型**）最终还是**要靠类加载器来完成加载**，一个数组类（简称C）创建过程遵循以下规则<br />·  如果数组的**组件类型**（Component Type，指的是**数组去掉一个维度的类型**，注意**和前面的元素类型区分开来**）是**引用类型**，那就**递归**采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上  <br />· 如果数组的组件类型**不是引用类型**，Java虚拟机会把**数组C标记为与引导类加载器关联**<br />·  数组类的**可访问性与它的组件类型的可访问性一致**，如果组件类型**不是引用类型**，它的数组类的可访问性将**默认为public**，可被所有的类和接口访问到  <br /> 加载阶段结束后，Java虚拟机外部的**二进制字节流**就按照**虚拟机所设定的格式**存储在**方法区**之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，**会在Java堆内存中实例化一个java.lang.Class类的对象**， 这个对象将作为**程序访问方法区中的类型数据的外部接口。**
<a name="OaYcX"></a>
##### 7.3.2 验证
 **验证**是**连接阶段的第一步**，这一阶段的目的是**确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求**，保证这些信息被当作代码运行后不会危害虚拟机自身的安全。 <br /> **验证阶段**大致上会完成下面四个阶段的检验动作：**文件格式验证**、**元数据验证**、**字节 码验证**和**符号引用验证**。

1. **文件格式验证**

 第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：<br />·是否以魔数0xCAFEBABE开头。 <br />·主、次版本号是否在当前Java虚拟机接受范围之内。 <br />·常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。 <br />·指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。 <br />·CONSTANT_Utf8_info型的常量中是否有不符合UTF-8编码的数据。 <br />·Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。<br /> 实际上第一阶段的验证点还远不止这些，上面所列的只是从HotSpot虚拟机源码中摘抄的一小部分内容，该验证阶段的**主要目的**是**保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求**。这阶段的验证是**基于二进制字节流进行的**，只有通过了这个阶段的验证之后，这段**字节流**才被**允许进入Java虚拟机内存的方法区中进行存储**，所以**后面的三个验证阶段**全部是**基于方法区的存储结构上进行的**，不会再直接读取、操作字节流了。

2. **元数据验证**

第二阶段是**对字节码描述的信息进行语义分析**，以保证其描述的信息符合《Java语言规范》的要求，这个阶段可能包括的验证点如下：<br />· 这个类是否有父类<br />· 这个类的父类是否继承了不允许被继承的类<br />· 如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法<br />· 类中的字段，方法是否与父类产生矛盾(例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数都一致，但返回值的类型却不同等)。<br />......<br />第二阶段的**主要目的**是**对类的元数据信息进行语义校验，保证不存在与《Java语言规范》定义相悖的元数据信息**。

3. **字节码验证**

第三阶段是整个验证过程中**最复杂的一个阶段**，主要目的是**通过数据流分析和控制流分析，确定程序语义是合法的，符合逻辑的**。在第二阶段中对元数据信息中的数据类型校验完毕以后，这阶段就要**对类的方法体(Class文件中的Code属性)进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为**，例如：<br />·  保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况。<br />·  保证**任何跳转指令都不会跳转到方法体以外的字节码指令**上。  <br />·  保证**方法体中的类型转换总是有效的**，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但是把父类对象赋值给子类数据类型，甚至把对象赋值给与它毫无继承关系、完全不相干的一个数据类型，则是危险和不合法的。<br />......<br /> 如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；但如果一个方法体通过了字节码验证，也仍然不能保证它一定就是安全的。即使字节码验证阶段中进行了再大量、再严密的检查，也依然不能保证这一点。

4. **符号引用验证**

最后一个阶段的校验行为发生在**虚拟机将符号引用转化为直接引用的时候**，这个转化动作将在连接的第三阶段——**解析阶段**发生。**符号引用验证**可以看作是**对类自身以外的各类信息进行匹配性校验**，通俗来说就是，**该类是否缺少或者被禁止访问它所依赖的某些外部类，方法，字段等资源**。本阶段通常需要校验下列内容：<br />· 符号引用中通过字符串描述的全限定名是否能找到对应的类。<br />· 在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段<br />· 符号引用中的类，字段，方法的可访问性是否可被当前类访问<br />......<br /> 符号引用验证的主要目的是确保解析行为能正常执行，如果无法通过符号引用验证，Java虚拟机将会抛出一个java.lang.IncompatibleClassChangeError的子类异常  <br />  验证阶段对于虚拟机的类加载机制来说，是一个非常重要的、但却不是必须要执行的阶段，因为验证阶段只有通过或者不通过的差别，只要通过了验证，其后就对程序运行期没有任何影响了。如果程序运行的全部代码（包括自己编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用-Xverify：none参数来关闭大部分的 类验证措施，以缩短虚拟机类加载的时间。  
<a name="wyiBP"></a>
##### 7.3.3 准备
**准备阶段**是**正式为类中定义的变量(即静态变量，被static修饰的变量)分配内存并设置类变量初始值的阶段**，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域， 在JDK 7及之前，HotSpot使用永久代来实现方法区时，实现是完全符合这种逻辑概念的；而在**JDK 8及之后**，**类变量则会随着Class对象一起存放在Java堆中**，这时候“**类变量在方法区**”就完全**是一种对逻辑概念的表述了。**<br />关于准备阶段，还有两个容易产生混淆的概念，首先是**这时候进行内存分配的仅包括类变量**，而**不包括实例变量**，**实例变量将会在对象实例化时随着对象一起分配在Java堆中**。其次是这里所说的初始值通常情况下是数据类型的零值，假设一个类变量定义为：<br />`public static int value = 123;`<br />那变量value在准备阶段过后的**初始值为0而不是123**，因为这时尚未开始执行任何Java方法，而**把value赋值为123的putstatic指令**是程序被编译后，**存放于类构造器<clinit>()方法之中**，所以**把value赋值为123的动作要到类的初始化阶段才会被执行**。<br />-- 解释一下**类变量和实例变量的区别**：<br />**类变量**是**定义在类中**，**但是在任何实例之外的变量**。它们**可以通过类名来访问和修改，也可以通过任何该类的实例来访问**。当一个类变量被**修改时**，这个改变将对**所有实例生效**。<br />**实例变量**则是**定义在类实例化后**，**作为实例的属性赋值的变量**。每个实例都有自己的一组实例变量。它们**只能通过实例名来访问和修改**。<br />因此，类变量通常用于存储与该类的所有实例相关的信息，而实例变量则用于存储与特定实例相关的信息。
```java
public class MyClass {
    public static int classVar = 0;  // 类变量
    public int instanceVar;  // 实例变量

    public MyClass(int instanceVar) {
        this.instanceVar = instanceVar;
    }

    public static void main(String[] args) {
        MyClass myObj1 = new MyClass(1);
        MyClass myObj2 = new MyClass(2);

        // 访问类变量
        System.out.println(MyClass.classVar);   // 输出: 0
        System.out.println(myObj1.classVar);   // 输出: 0
        System.out.println(myObj2.classVar);   // 输出: 0

        // 修改类变量
        MyClass.classVar = 1;
        System.out.println(MyClass.classVar);   // 输出: 1
        System.out.println(myObj1.classVar);   // 输出: 1
        System.out.println(myObj2.classVar);   // 输出: 1

        // 修改实例变量
        myObj1.instanceVar = 3;
        myObj2.instanceVar = 4;
        System.out.println(myObj1.instanceVar);   // 输出: 3
        System.out.println(myObj2.instanceVar);   // 输出: 4
    }
}
```
在这个例子中，**classVar 是一个类变量**，表示**所有 MyClass 实例共享的值**。**instanceVar 则是一个实例变量**，在**每个实例中都有自己的值**。<br />当我们修改类变量 classVar 的值时，它将对该类的所有实例生效，包括之前创建的实例和之后创建的实例。但是，当我们修改实例变量 instanceVar 的值时，只会影响当前实例的值，不会影响其他实例或类本身。
<a name="JjRQR"></a>
##### 7.3.4 解析
**解析阶段**是Java虚拟机将**常量池内的符号引用**替换为**直接引用**的**过程**，在Class文件中它以 以CONSTANT_Class_info、 CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现，符号引用与直接引用又有什么区别呢。<br />· **符号引用**：符号引用**是以一组符号来描述所引用的目标**，符号**可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可**。符号引用**与虚拟机实现的内部布局无关**，引用的目标并**不一定是已经加载到虚拟机内存当中的内容**。各种虚拟机实现的内存布局可以各不相同，但它们**能接受的符号引用必须都是一致**的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。<br />· **直接引用**：直接引用是**可以直接指向目标的指针，相对偏移量或者是一个能间接定位到目标的句柄**。直接引用和**虚拟机实现的内存布局直接相关**，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那**引用的目标必定已经在虚拟机的内存中存在**。<br /> 以虚拟机实现可以根据需要来自行判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。<br /> 对同一个符号引用进行多次解析请求是很常见的事情，**除invokedynamic指令以外**，虚拟机实现**可以对第一次解析的结果进行缓存**，譬如在运行时直接引用常量池中的记录，并把常量**标识为已解析状态**，从而**避免解析动作重复进**行。无论是否真正执行了多次解析动作，Java虚拟机都需要保证的是在同一个实体中，如果**一个符号引用之前已经被成功解析过**，那么**后续的引用解析请求就应当一直能够成**功；同样地，如果**第一次解析失败**了，其他指令**对这个符号的解析请求也应该收到相同的异常**，哪怕这个请求的符号在后来已成功加载进Java虚拟机内存之中。   <br /> 不过**对于invokedynamic指令**，上面的规则就不成立了。当**碰到某个前面已经由invokedynamic指令触发过解析的符号引用时**，并**不意味着这个解析结果对于其他invokedynamic指令也同样生效**。因为 invokedynamic指令的**目的本来就是用于动态语言支持**，它对应的引用称为“动态调用点限定符 （Dynamically-Computed Call Site Specifier）”，这里“**动态**”的含义是指**必须等到程序实际运行到这条指令时，解析动作才能进行**。相对地，其余可触发解析的指令都是“静态”的，可以在刚刚完成**加载**阶段，还**没有开始执行代码**时就提前进行**解析**。<br /> 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行  
<a name="asUqi"></a>
##### 7.3.5 初始化
类的**初始化阶段**是**类加载过程的最后一个步骤**，之前介绍的几个类加载的动作里，除了在加载阶段用户程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由Java虚拟机来主导控制。直到**初始化阶段**，Java虚拟机才**真正开始执行类中编写的Java程序代码**，将主导权移交给应用程序。<br />进行**准备阶段**，变量**已经赋过**一次系统要求的**初始零值**，而在**初始化阶段**，则会**根据程序员通过程序编码制定**的主观计划去**初始化类变量和其他资源**。我们也可以从另外一种更直接的形式来表达：**初始化阶段**就是**执行类构造器<clinit>()方法的过程**。**<clinit>()**并不是程序员在Java代码中直接编写的方法，它**是Java编译器的自动生成物**，但我们非常有必要了解这个方法具体是如何产生的，以及<clinit>()方法执行过程中各种可能会影响程序运行行为的细节。<br />· **<clinit>()方法**是由**编译器**自动收集**类中的所有类变量的赋值动作**和**静态语句块(static{}块)中的语句**合并产生的，编译器**收集的顺序**是由**语句在源文件中出现的顺序决定**的，静态语句块中**只能访问**到**定义在静态语句块之前的变量**，定义在它**之后的变量**，在前面的静态语句块**可以赋值，但是不能访问**
```java
public class Test{
    static{
        i=0; //给变量赋值可以正常编译通过
        System.out.printf(i); //这句编译器会提示"非法向前引用"
    }
    static int i=1;
}
```
	· **<clinit>()方法**与类的**构造函数**（即在虚拟机视角中的实例构造器**<init>()方法**）**不同**，它**不需要显式地调用父类构造器**，Java虚拟机会**保证在子类的<clinit>()方法执行前**，**父类**的<clinit>()方法已经**执行完毕**。因此在Java虚拟机中第一个被执行的<clinit>()方法的类型肯定是java.lang.Object<br />· 由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作，如下列代码，字段B的值将会是2而不是1
```java
static class Parent {
	public static int A = 1;
	static {
		A = 2;
	}
}

static class Sub extends Parent {
	public static int B = A;
}
public static void main(String[] args) {
	System.out.println(Sub.B);
}
```
·** <clinit>()方法**对于类或接口来说并**不是必需的**，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<clinit>()方法<br />· **接口**中**不能使用静态语句块**，但仍然**有变量初始化的赋值**操作，因此接口与类一样都会**生成<clinit>()方法**。但接口与类不同的是，执行接口的<clinit>()方法**不需要先执行父接口**的<clinit>()方法。只有当**父接口中定义的变量**被**使用**时，**父接口才会被初始化**。此外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法<br />·  Java虚拟机必须保证一个类的<clinit>()方法在多线程环境中被**正确地加锁同步**，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行完毕<clinit>()方法。如果在**一个类的<clinit>()方法中有耗时很长的操作**，那就**可能造成多个进程阻塞**，在实际应用中这种阻塞往往是很隐蔽的 <br />同一个类加载器下，一个类型只会被初始化一次
<a name="O8aTD"></a>
#### 7.4 类加载器
Java虚拟机设计团队有意把类加载阶段中的"**通过一个类的全限定名来获取描述该类的二进制字节流**"这个动作放到**Java虚拟机外部去实现**，以便让**应用程序自己决定**如何去获取所需的类。实现这个动作代码被称为"**类加载器**"。
<a name="UeECh"></a>
##### 7.4.1 类与类加载器
类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。**对于任意一个类**，都**必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性**，**每一个类加载器都有一个独立的类名称空间**。这句话可以表达的更通俗一些：比较两个类**是否"相等"**，只有在**两个类是由同一个类加载器加载**的前提下才**有意义**，否则。即使这两个类来源于同一个Class文件，被同一个Java虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。<br />这里所指的"相等"，包括代表类的Class对象的equals()方法，isAssignableFrom()方法，isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。如果没有注意到类加载器的影响，在某些情况下可能会产生具有迷惑性的结果。
<a name="BW9j4"></a>
##### 7.4.2 双亲委派模型
站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器 （Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类 java.lang.ClassLoader。  <br /> 站在Java开发人员的角度来看，类加载器就应当划分得更细致一些。自JDK 1.2以来，Java一直保持着**三层类加载器、双亲委派的类加载架构**<br />· **启动类加载器（Bootstrap Class Loader）**：前面已经介绍过，这个类加载器负责加载存放在 **<JAVA_HOME>\lib **目录，或者被**-Xbootclasspath**参数所指定的路径中存放的，而且是**Java虚拟机能够识别**的（按照文件名识别，如rt.jar、tools.jar，名字不符合的类库即使放在lib目录中也不会被加载）**类库**加载到虚拟机的内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时， 如果需要把加载请求委派给**引导类加载器**去处理，那直接使用**null**代替即可 <br />· **扩展类加载器（Extension Class Loader）**：这个类加载器是在类sun.misc.Launcher$ExtClassLoader 中以Java代码的形式实现的。它负责加载**<JAVA_HOME>\lib\ext**目录中，或者被java.ext.dirs系统变量所 指定的路径中所有的类库。根据“**扩展类加载器**”这个名称，就可以推断出这是一种**Java系统类库的扩展机制**，JDK的开发团队允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK 9之后，这种扩展机制被模块化带来的天然的扩展能力所取代。由于扩展类加载器是由Java代码实现 的，开发者**可以直接在程序中使用扩展类加载器来加载Class文件**。 <br />· **应用程序类加载器（Application Class Loader）**：这个类加载器由 sun.misc.Launcher$AppClassLoader来实现。由于应用程序类加载器是ClassLoader类中的getSystem-ClassLoader()方法的返回值，所以有些场合中也称它为“系统类加载器”。它负责加载用户类路径 （ClassPath）上所有的类库，开发者同样可以直接在代码中使用这个类加载器。如果应用程序中**没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器**。  <br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683617449987-3eaecc2d-35be-46f0-837b-f1fe7d8d3773.png#averageHue=%23d7b58a&clientId=ucc8c0985-dcc2-4&from=paste&height=608&id=u97c01fe9&originHeight=1064&originWidth=1109&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=327639&status=done&style=none&taskId=u4e6716a3-10fb-42e5-a4d4-be2ad6c191d&title=&width=633.7142857142857)

图7-2中展示的各种**类加载器之间的层次关系**被称为**类加载器的“双亲委派模型（Parents Delegation Model）**”。双亲委派模型要求**除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器**。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用**组合（Composition）**关系来复用父加载器的代码。<br />双亲委派模型的**工作过程**是：如果一个类加载器收到了类加载的请求，它**首先不会自己去尝试加载这个类**，而是把这个请求**委派给父类加载器去完成**，每一个层次的类加载器都是如此，因此**所有的加载请求最终都应该传送到最顶层的启动类加载器中**，**只有当父加载器反馈自己无法完成这个加载请求**（它的搜索范围中没有找到所需的类）时，**子加载器才会尝试自己去完成加载**。<br />使用**双亲委派模型**来组织类加载器之间的关系，一个显而易见的好处就是Java中的**类随着它的类加载器**一起**具备了一种带有优先级的层次关系**。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是**委派给处于模型最顶端的启动类加载器进行加载**，因此**Object类**在程序的各种类加载器环境中都**能够保证是同一个类**。反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object的类，并放在程序的 ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。如果读者有兴趣的话，可以尝试去写一个与rt.jar类库中已有类重名的Java 类，将会发现它可以正常编译，但永远无法被加载运行。
<a name="GJxB1"></a>
##### 7.4.3 破坏双亲委派模型
 双亲委派模型的**第一次“被破坏”**其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。由于**双亲委派模型在JDK 1.2之后才被引入**，但是**类加载器的概念和抽象类 **java.lang.ClassLoader则在**Java的第一个版本中就已经存在**，面对**已经存在的用户自定义类加载器的代码**，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能**在JDK 1.2之后的java.lang.ClassLoader中添加一个新的 protected方法findClass()**，并引导用户编写的类加载逻辑时**尽可能去重写这个方法**，而不是在 loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面， 按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。 <br /> 双亲委派模型的**第二次“被破坏”**是由这个**模型自身的缺陷导致的**，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（**越基础的类由越上层的加载器进行加载**），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果**有基础类型又要调用回用户的代码**，那该怎么办呢？ 为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：**线程上下文类加载器 （Thread Context ClassLoader）**。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是**应用程序类加载器**。 JNDI服务使用这个**线程上下文类加载器**去加载所需的SPI服务代码，这是一种**父类加载器去请求子类加载器完成类加载的行为**，这种行为实际上是打通了双亲委派模型的层次结构来**逆向使用类加载器**，已经违背了双亲委派模型的一般性原则。
<a name="bdXBw"></a>
### 第8章 虚拟机字节码执行引擎
<a name="TcPae"></a>
#### 8.1 概述
执行引擎是Java虚拟机核心的组成部分之一。"虚拟机"是一个相对于"物理机"的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器，缓存，指令集和操作系统层面上的，而虚拟机的执行引擎则是由软件自行实现的，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，能够执行那些不被硬件直接支持的指令集格式。
<a name="BBVsg"></a>
####  8.2 运行时栈帧结构
Java虚拟机以方法作为最基本的执行单元，"栈帧"则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量表，操作数栈，动态连接和方法返回地址等信息。**每一个方法从调用开始至执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程**。<br />每一个栈帧都包括了局部变量表，操作数栈，动态连接，方法返回地址和一些额外的附加信息。在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性中。换而言之，一个栈帧需要分配多少内存，并不会收到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。<br />一个线程中的方法调用链可能会很长，以Java程序的角度来看，同一时刻，同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，这被称为"当前栈帧"，与这个栈帧所关联的方法被称为"当前方法"。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图所示<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683619888716-b807a923-1c49-4cc5-9339-5af7da04ce16.png#averageHue=%23f6f6f6&clientId=ucc8c0985-dcc2-4&from=paste&height=706&id=u8d741d87&originHeight=1235&originWidth=1084&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=233657&status=done&style=none&taskId=u58a76d86-747e-43c2-b5bb-e4939c9a84c&title=&width=619.4285714285714)
<a name="NtDH4"></a>
##### 8.2.1 局部变量表
局部变量表是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量<br />**局部变量表的容量以变量槽为最小单位**，《Java虚拟机规范》中并没有明确指出一个变量槽应占用的内存大小，只是很有导向性地说每个变量槽都应该能存放一个boolean， byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储，但这种描述与明确指出“每个变量槽应占用32位长度的内存空间”是有本质差别的，它允许变量槽的长度可以随着处理器、操作系统或虚拟机实现的不同而发生变化，保证了即使在64位虚拟机中使用了64位的物理内存空间去实现一个变量槽，虚拟机仍要使用对齐和补白的手段让变量槽在外观上看起来与32位虚拟机中的一致。<br />一个变量槽可以存放一个32位以内的数据类型，Java中占用不超过32位存储空间的类型数据有 boolean、byte、char、short、int、 float、reference和returnAddress这8种类型， **第7种reference类型**表示对一个**对象实例的引用**，《Java虚拟机规范》既没有说明它的长度，也没有明确指出这种引用应有怎样的结构。但是一般来说，虚拟机实现至少都应当能通过这个引用做到两件事情，一是从**根据引用直接或间接地查找到对象在Java堆中的数据存放的起始地址或索引**，二是**根据引用直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息**，否则将无法实现《Java语言规范》中定义的语法约定。<br />对于64位的数据类型，Java虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间。<br /> Java虚拟机通过**索引定位的方式使用局部变量表**，索引值的范围是从0开始至局部变量表最大的 量槽数量。如果**访问的是32位数据类型**的变量，**索引N就代表了使用第N个变量槽**，如果**访问的是64位数据类型的变量**，则说明会**同时使用第N和N+1两个变量槽**。对于两个相邻的共同存放一个64位数据的两个变量槽，虚拟机**不允许采用任何方式单独访问其中的某一个。**<br />当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果**执行的是实例方法**（没有被static修饰的方法），那**局部变量表中第0位索引**的**变量槽**默认是**用于传递方法所属对象实例的引用**，方法中可以**通过关键字"this"**来**访问**到这个**隐含的参数**。其余则按照参数表顺序排列，占用从1开始的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。<br />为了尽可能节省栈帧耗用的内存空间，**局部变量表中的变量槽是可以重用的**，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果**当前字节码PC计数器的值以及超出了某个变量的作用域**，那这个**变量对应的变量槽就可以交给其他变量来重用**。不过，这样的设计除了节省栈帧空间以外，还会伴有少量额外的副作用。<br /> 关于局部变量表，还有一点可能会对实际开发产生影响，就是局部变量不像前面介绍的类变量那样存在“准备阶段”。通过第7章的学习，我们已经知道**类的字段变量有两次赋初始值的过程**，**一次在准备阶段**，赋予**系统初始值**；另外**一次在初始化阶段**，赋予**程序员定义的初始值**。因此即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值，不会产生歧义。但**局部变量就不一样**了，如果**一个局部变量定义了但没有赋初始值，那它是完全不能使用的。**  
<a name="ri4zT"></a>
##### 8.2.2 操作数栈
**操作数栈也常被称为操作栈**，它是一个**后入先出栈**。同局部变量表一样，操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项中。操作数栈的每一个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量位1，64位数据类型所占的栈容量为2。<br /> 当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在**方法的执行过程中**，会有各种字节码指令**往操作数栈中写入和提取内容**，也就是**出栈和入栈**操作。<br /> 在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是**完全相互独立**的。但是在大多虚拟机的实现里都会进行一些**优化处理**，**令两个栈帧出现一部分重叠**。让**下面栈帧的部分操作数栈**与**上面栈帧的部分局部变量表**重叠在一起，这样做不仅**节约了一些空间**，更重要的是在进行方法调用时就可以**直接共用一部分数据**，无须进行额外的参数复制传递了。 <br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683621969960-e65a5227-3288-4781-8864-a8e404228f2e.png#averageHue=%23f9f9f9&clientId=ucc8c0985-dcc2-4&from=paste&height=521&id=uddd355e9&originHeight=912&originWidth=1099&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=160621&status=done&style=none&taskId=uf844e8c4-2589-4792-94ba-c0e378e69ae&title=&width=628)
<a name="R2A0H"></a>
##### 8.2.3 动态连接
**每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用**，持有这个引用是为了支持方法调用过程中的**动态连接**。**Class文件的常量池**中存有**大量的符号引用**，字节码中的方法调用指令就以**常量池里指向方法的符号**引用作为**参数**。这些**符号引用一部分会在类加载阶段或者第一次使用的时候**就被转化为**直接引用**，这种转化被称为**静态解析**。**另外一部分将在每一次运行期间**都转化为**直接引用**，这部分称为**动态连接**。
<a name="FOWnI"></a>
##### 8.2.4 方法返回地址
当一个方法开始执行后，**只有两种方式退出这个方法**。**第一种方式**是**执行引擎遇到任意一个方法返回的字节码指令**，这时候**可能会有返回值**传递给上层的方法调用者，方法是否有返回值以及返回值的类型将根据遇到何种方法返回指令来决定，这种推出方法的方式称为**”正常调用完成“**。<br />**另一种退出方式**是在**方法执行**的过程中**遇到了异常**，并且这个异常没有在方法体内得到妥善处理。无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为"**异常调用完成**"。一个方法使用异常完成出口的方式退出，是**不会给它的上层调用者提供任何返回值的**。<br />无论采用何种退出方式，在**方法退出之后**，都**必须返回到最初方法被调用时的位置**，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用于**恢复它的上层主调方法的执行状态**。一般来说，方法正常退出时，**主调方法**的**PC计数器的值**就可以**作为返回地址**，栈帧中和可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。<br />**方法退出的过程**实际上等同于把**当前栈帧出栈**，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把**返回值压入调用者**栈帧的**操作数栈中**，调整**pc计数器**的**值**以**指向方法调用指令后面的一条指令**等。
<a name="a6mQi"></a>
#### 8.3 方法调用
 方法调用并不等同于方法中的代码被执行，方法调用阶段**唯一的任务**就是**确定被调用方法的版本** （即**调用哪一个方法**）  <br /> **Class文件的编译过程**中**不包含**传统程序语言编译的**连接步骤**，**一切方法调用**在**Class文件里面存储**的都**只是符号引用**，而**不是**方法在**实际运行**时**内存布局中的入口地址**（也就是之前说的**直接引用**）
<a name="CE8Rh"></a>
##### 8.3.1 解析
所有**方法调用的目标方法**在**Class文件**里面都是一个**常量池中的符号引用**，在类加载的解析阶段，会将其中的**一部分符号引用转化为直接引用**，这种**解析**能够成立的前提是：方法在程序**真正运行之前**就有一个**可确定的调用版本**，并且这个方法的调用版本在**运行期**是**不可改变的**。换句话说，调用目标在程序代码写好，编译器进行编译那一刻就已经确定下来，这类方法的调用被称为**解析(Resolution)**。<br />在Java语言中符合”**编译期可知，运行期不可变**“这个要求的方法，主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问。这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析。<br /> 调用不同类型的方法，字节码指令集里设计了不同的指令。在Java虚拟机支持以下5条方法调用字节码指令，分别是： <br />·**invokestatic**。用于调用静态方法。 <br />·**invokespecial**。用于调用实例构造器()方法、私有方法和父类中的方法。<br />·invokevirtual。用于调用所有的虚方法。 <br />·invokeinterface。用于调用接口方法，会在运行时再确定一个实现该接口的对象。  <br />·invokedynamic。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而**invokedynamic**指令的**分派逻辑**是由**用户设定的引导方法来决定的**。 <br />只要能被**invokestatic**和**invokespecial**指令调用的方法，都可以在**解析阶段中确定唯一的调用版本**， Java语言里符合这个条件的方法共有**静态方法、私有方法、实例构造器、父类方法4种**，再加上被**final**修饰的方法（尽管它使用invokevirtual指令调用），这5种方法调用会在**类加载的时候**就可以把**符号引用解析为该方法的直接引用**。这些方法统称为“**非虚方法**”（Non-Virtual Method），与之相反，**其他方法就被称为“虚方法”**（Virtual Method）。<br /> **解析调用**一定是个**静态的过程**，在**编译期间就完全确定**，在类加载的解析阶段就会把涉及的**符号引用全部转变为明确的直接引用**，不必延迟到运行期再去完成。   
<a name="WTDEm"></a>
##### 8.3.2 分派
 Java是一门面向对象的程序语言，因为Java具备面向对象的3个基本特征：继承、封装 和多态。分派调用过程将会揭示多态性特征的一些最基本的体现，如“重载”和“重写”在 Java虚拟机之中是如何实现的。
<a name="I3tBU"></a>
###### **静态分派**
```java
public class StaticDispatch {
	static abstract class Human {
	}
		static class Man extends Human {
	}
	static class Woman extends Human {
	}
public void sayHello(Human guy) {
	System.out.println("hello,guy!");
}
public void sayHello(Man guy) {
	System.out.println("hello,gentleman!");
}
public void sayHello(Woman guy) {
	System.out.println("hello,lady!");
}
public static void main(String[] args) {
	Human man = new Man();
	Human woman = new Woman();
	StaticDispatch sr = new StaticDispatch();
	sr.sayHello(man);
	sr.sayHello(woman);
}

// 运行结果
// hello,guy!
// hello,guy!

```
 为什么虚拟机会选择执行参数类型为Human的重载版本呢？  <br />`Human man = new Man();`<br />我们把上面代码中的**"Human"称为变量的静态类型**，或者叫**外观类型**，后面的**"Man"则称为变量的实际类型**或者叫**运行时类型**。静态类型和实际类型在程序中都可能会发生变化，区别**静态类型的变化仅仅在使用时发生**，**变量本身**的**静态类型不会被改变**，并且**最终的静态类型是在编译期可知的**；而**实际类型**变化的结果在**运行期才可确定**，编译器在编译程序的时候并不知道一个对象的实际类型是什么。
```java
// 实际类型变化
Human human = (new Random()).nextBoolean() ? new Man() : new Woman();
// 静态类型变化
sr.sayHello((Man) human);
sr.sayHello((Woman) human);
```
对象human的实际类型是可变的，编译期间它完全是一个"薛定谔的人"，编译器无法得知到底是Man还是Woman，必须等到程序运行到这行时才能确定。而**human的静态类型时Human**，也可以在**使用时**(入sayHello()方法中的强制转型)**临时改变这个类型**，但这个改变仍是在**编译期可知**的，两次sayHello()方法的调用，在**编译期完全可以确定转型的是Man还是Woman**。<br />在”方法静态分派演示“代码中，main()里面的两次sayHello()方法调用，在方法接收者已经确定是对象"sr"的前提下，**使用哪个重载版本**，就**完全取决于传入参数的数量和数据类型**。代码中故意定义了**两个静态类型相同**，而**实际类型不同的变量**，但**虚拟机**在**重载时**是通过参数的静态类型而不是实际类型作为判定依据的。由于**静态类型**在**编译期可知**，所以在**编译阶段**，Javac编译器就**根据参数的静态类型**决定了会**使用哪个重载版本**，因此选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到了main()方法里的两条invokevirtual指令的参数中。<br />所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。静态分派最典型应用表现就是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。
<a name="HqYjk"></a>
###### **动态分派**
了解了静态分派，接下来看一下Java语言里动态分派的实现过程，它与Java语言多态性的另外一个重要体现——重写(Override)有着密切的关联。我们还是用前面的Man和Woman一起sayHello的例子来讲解动态分派
```java
public class DynamicDispatch {
	static abstract class Human {
		protected abstract void sayHello();
	}
	static class Man extends Human {
		@Override
		protected void sayHello() {
			System.out.println("man say hello");
		}
	}
static class Woman extends Human {
	@Override
	protected void sayHello() {
		System.out.println("woman say hello");
	}
}
public static void main(String[] args) {
	Human man = new Man();
	Human woman = new Woman();
	man.sayHello();
	woman.sayHello();
	man = new Woman();
	man.sayHello();
}

// 运行结果
// man say hello
// woman say hello
// woman say hello   
```
	显然这里选择调用的方法版本是不饿能再根据静态类型来决定的，因为静态类型同样都是Human的两个变量man和woman在调用sayHello()方法时产生了不同的行为，甚至变量man在两次调用中还执行了两个不同的方法。导致这个现象的原因很明显，是因为这两个变量的实际类型不同，Java虚拟机是如何根据实际类型来分派方法执行版本的呢？我们可以使用javap命令输出这段代码的字节码，尝试从中寻找答案
```java
public static void main(java.lang.String[]);
	Code:
		Stack=2, Locals=3, Args_size=1
        0: new #16; //class org/fenixsoft/polymorphic/DynamicDispatch$Man
        3: dup
        4: invokespecial #18; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Man."<init>":()V
        7: astore_1
        8: new #19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman
        11: dup
        12: invokespecial #21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman."<init>":()V
        15: astore_2
        16: aload_1
        17: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V
        20: aload_2
        21: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V
        24: new #19; //class org/fenixsoft/polymorphic/DynamicDispatch$Woman
        27: dup
        28: invokespecial #21; //Method org/fenixsoft/polymorphic/DynamicDispatch$Woman."<init>":()V
        31: astore_1
        32: aload_1
        33: invokevirtual #22; //Method org/fenixsoft/polymorphic/Dynamic Dispatch$Human.sayHello:()V
        36: return
```
0-15行的字节码是准备动作，作用是建立man和woman的内存空间，调用Man和Woman类型的实例构造器，将这两个实例的引用存放在第1，2个局部变量表的变量槽中，这些动作实际对应了Java源码中的这两行：<br />`Human man = new Man();`<br />`Human woman = new Woman();`<br />接下来的16-21行是关键部分，16和20行的aload指令分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行sayHello()方法的所有者，称为接收者；17和21行是方法调用指令，这两条调用质量但从字节码角度来看，无论是指令 (invokevirtual) 还是参数(都是常量池中第22项的常量，注释显示了这个常量是Human.sayHello()的符号引用) 都完全一样，但是这两句指令最终执行的目标方法并不相同。解决问题的关键是从invokevirtual指令本身入手，要弄清invokevirtual指令的运行时解析过程大致分为以下几步：<br />1）**找到操作数栈顶的第一个元素所指向的对象的实际类型**，记作C<br />2）如果**在类型C中找到与常量中的描述符和简单名称都相符的方法**，则进行访问权限校验，如果通过则返回这个方法的**直接引用**，查找过程结束；不通过则返回 java.lang. IllegalAccessError异常  <br />3）**否则**，按照**继承关系从下往上**依次对C的各个父类进行第二步的**搜索和验证**过程<br />4）如果始终没有找到合适的方法，则抛出 java.lang.AbstractMethodError异常<br />正是因为**invokevirtual指令**执行的**第一步**就是在**运行期确定接收者的实际类型**，所以两次调用中的invokevirtual指令**并不是**把常量池中方法的**符号引用解析到直接引用上就结束了**，还会**根据方法接收者的实际类型来选择方法版本**，这个过程就是**Java语言中方法重写的本质**。我们把这种在**运行期根据实际类型确定方法执行版本的分派过程**称为**动态分派**<br /> 既然这种多态性的**根源**在于**虚方法调用指令invokevirtual的执行逻辑**，那自然我们得出的结论就**只会对方法有效，对字段是无效的，因为字段不使用这条指令**。事实上，在Java里面只有虚方法存在， 字段永远不可能是虚的，换句话说，字段永远不参与多态，哪个类的方法访问某个名字的字段时，该名字指的就是这个类能看到的那个字段。当子类声明了与父类同名的字段时，虽然在子类的内存中两个字段都会存在，但是子类的字段会遮蔽父类的同名字段。  
<a name="B4CmT"></a>
###### **单分派与多分派**
方法的接收者与方法的参数统称为方法的宗量。根据分派基于多少种宗量，可以将分派划分为单分派和多分派。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。
```java
public class Dispatch {
    static class QQ {}
    static class _360 {}
	public static class Father {
		public void hardChoice(QQ arg) {
			System.out.println("father choose qq");
		}
	public void hardChoice(_360 arg) {
			System.out.println("father choose 360");
		}
	}
    public static class Son extends Father {
        public void hardChoice(QQ arg) {
        	System.out.println("son choose qq");
        }
        public void hardChoice(_360 arg) {
        	System.out.println("son choose 360");
        }
    }
    public static void main(String[] args) {
        Father father = new Father();
        Father son = new Son();
        father.hardChoice(new _360());
        son.hardChoice(new QQ());
    }
}

// 运行结果
// father choose 360
// son choose qq
```
在main()里面调用了**两次hardChoice()方法**，这两次hardChoice方法的选择结果也在程序输出中已经显示得很清楚了。我们关注的首先是**编译阶段**中编译器的选择过程，也就是**静态分派的过程(重载)**。这时候选择目标方法的依据有**两点**：**一是静态类是是Father还是Son**，**二是方法参数是QQ还是360**。这次选择结果的最终产物是**产生了两条invokevirtual指令**，两条指令的参数分别为常量池中指向 Father::hardChoice(360)及Father::hardChoice(QQ)方法的符号引用。因为是**根据两个宗量**进行选择，所以Java语言的**静态分派**属于**多分派类型**。 <br />再看运行阶段中虚拟机的选择，也就是**动态分派的过程(重写)**。在执行“son.hardChoice(new QQ())”这行代码时，更准确地说，是在执行这行代码所对应的**invokevirtual指令**时，由于编译期已经决定目标方法的签名必须为**hardChoice(QQ)**，虚拟机此时不会关心传递过来的参数“QQ”到底是“腾讯QQ”还是“奇瑞QQ”，因为这时候参数的静态类型、实际类型都对方法的选择不会构成任何影响，**唯一**可以影响虚拟机**选择的因素**只有**该方法的接受者的实际类型是Father还是Son**。因为**只有一个宗量**作为选择依据， 所以Java语言的**动态分派**属于**单分派**类型。   
<a name="e0m6g"></a>
###### 虚拟机动态分派的实现
前面介绍的分派过程，作为对Java虚拟机概念模型的解释基本上已经足够，它已经解决了虚拟机在分派中"会做什么"这个问题。但如果问Java虚拟机具体如何做到的，答案则可能因各种虚拟机的实现不同会有些差别<br />**动态分派**是执行非常频繁的动作，而且动态分配的**方案版本选择过程**需要**运行时在接收者类型的方法元数据中搜索合适的目标方法**。因此，Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地区反复搜索类型元数据。面对这种情况，一种基础而且常见的优化手段是为类型在方法区中建立一个虚方法表 （Virtual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也会用到接口方法表——Interface Method Table，简称itable），使用虚方法表索引来替代元数据查找以提高性能。<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/34408480/1683630370436-f8a6d18f-d2d5-43bc-aa17-24d895516573.png#averageHue=%23f4f4f4&clientId=uadad1d61-484a-4&from=paste&height=473&id=uc9a41b01&originHeight=828&originWidth=1101&originalType=binary&ratio=1.75&rotation=0&showTitle=false&size=355816&status=done&style=none&taskId=ud3c19e18-6f15-4782-9065-90ec3bcaee1&title=&width=629.1428571428571)<br />**虚方法表**中存放着**各个方法的实际入口地址**。如果**某个方法**在**子类中没有被重写**，那**子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的**，都指向父类的实现入口。如果子类中**重写了这个方法**，那么子类虚方法表中的地址也会被**替换成为指向子类实现版本的入口地址**。 在图8-3中，Son重写了来自Father的全部方法，因此Son的方法表没有指向Father类型数据的箭头。但是Son和Father都没有 重写来自Object的方法，所以它们的方法表中所有从Object继承来的方法都指向了Object的数据类型。
